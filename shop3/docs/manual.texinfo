\input texinfo
@macro sysname {}
@sc{Shop3}
@end macro
@macro SHOP {}
@sc{Shop}
@end macro
@macro shoptwo {}
@sc{Shop2}
@end macro


@include include/sb-texinfo.texinfo


@settitle SHOP3 Manual
@copying
Copyright @copyright{} 2018-2021 SIFT, LLC.
Original materials @copyright{} 2002 University of Maryland.

This document is made available under the Creative Commons
Attribution-ShareAlike 4.0 International Public License
@end copying

@titlepage
@title SHOP3 Manual
@center @image{img/shop3-logo, 4in}
@author Robert P. Goldman@sup{1}, Dana Nau@sup{2}, and Contributors
@sup{1} SIFT, LLC

319 North First Avenue, Suite 400

Minneapolis, MN 55401, USA

@sup{2} Department of Computer Science

University of Maryland

College Park, MD 20742, USA

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@contents


@ifnottex
@node Top, Introduction, (dir), (dir)
@top SHOP3 Manual

@center @image{img/shop3-logo-small}

@center Robert P. Goldman@sup{1}, Dana Nau@sup{2}, and Contributors

@sup{1} SIFT, LLC

319 North First Avenue, Suite 400

Minneapolis, MN 55401, USA

@sup{2} Department of Computer Science

University of Maryland

College Park, MD 20742, USA

@end ifnottex


@menu
* Introduction::
* Execution Environment::
* Running SHOP3::
* The SHOP3 Formalism::
* PDDL Support::
* The SHOP Theorem Prover::
* The SHOP Unifier::
* Plan Grapher::
* Data Structures::
* General Notes on @sysname {}: General Notes on SHOP3.
* Internal Technical Information::
* Acknowledgments::
* References::
* Function Index::
* Type and Class Index::
* Variable Index::
* Concept Index::
* Colophon::
@end menu



@node Introduction, Execution Environment, Top, Top
@chapter Introduction

AI planning is the subfield of artificial intelligence (AI) that aims at
automating processes of @emph{means-ends reasoning}.  In general,
AI planning is the problem of
finding a sequence of actions that, executed in a specified initial
state, will reach a goal state.  This is a problem with applications
to diverse areas including manufacturing, autonomous space and deep
sea exploration, medical treatment, and military operations, to name
just a few.  This is the manual for @sysname {}, the third major version
of the  Simple Hierarchical Ordered Planner.

An AI planning system takes as input a @emph{domain} -- a description
of available actions, relations, etc.; a @emph{problem} -- a
description of the initial state of the system, and an
@emph{objective}, a task to be performed or goal to be achieved.  From
these, it generates a @emph{plan}: a sequence of actions that, if
performed with the expected results, will attain the objective.  This
is the key function performed by @sysname {}, although, as will be
seen in this manual, many additional functions are offered.

@sysname {} is a domain-independent
planning system based on @strong{ordered task decomposition}, a
modified version of Hierarchical Task Network (HTN) planning that
involves planning for tasks in the same order that they will later be
executed. An HTN, or @emph{decomposition,} planner ``proceeds by
decomposing @emph{nonprimitive tasks} recursively into smaller and
smaller subtasks, until @emph{primitive tasks} are reached that can be
performed directly using the planning operators''
(@pxref{GhallabEtAl2004, , Ghallab et al.@comma{} 2004}).
This manual does not give an introduction to
HTN planning or AI planning in general, for that we recommend the
above-cited textbook and/or the research papers describing @sysname{}.

@sc{Shop} and @sc{Shop 2} were originally developed at the Computer
Science Department of the University of Maryland, College Park, by
Prof. Dana Nau's research group.  This manual draws heavily on
material from the manual for @sc{Shop2}, which was, in turn based, in
part, on the JSHOP documentation written by Füsun Yaman, with
additional material from Yue Cao's December 2000 draft of the @sc{Shop2}
documentation and pseudocode from Nau @emph{et al.}
(@pxref{NauEtAl2001, ,Nau et al.@comma{} 2001}).
Some
updates to the @sc{Shop2} manual were made by Robert P. Goldman and
John Maraist, of SIFT.

@sysname {} contains two important subsystems that perform useful
functions as part of it, but can also be used on their own.
The first is the @emph{unifier}, which computes the most general unifier
of two logical formulas, encoded as Lisp s-expressions.
@c FIXME: Add cite for the unification algorithm
The second subsystem is the @emph{theorem-prover}, which performs
Prolog-style rule-based Horn clause deduction over state sequences.
@c FIXME: When we have chapters for these, add cross-references.

Robert P. Goldman and Ugur Kuter have a paper in the European Lisp
Symposium describing @sysname{}
(@pxref{GoldmanKuter2019, , Goldman & Kuter@comma{} 2019}).


The planners in the @SHOP {} family have the following distinctive characteristics:

@itemize
@item
@SHOP {} knows the current state-of-the-world at each step of the planning
process.

@item
It has great expressive power, far beyond that of conventional PDDL planners.
For example, in the preconditions of
operators and methods it can do mixed symbolic/numeric computations and
execute calls to external programs.

@item
It can be used to create very efficient domain-specific planning
algorithms. The  software distribution includes several examples of
such domain-specific algorithms.

@c @item
@c An earlier version of the SHOP algorithm implemented in Java is used as
@c part of @uref{http://www.aic.nrl.navy.mil/hicap/,HICAP}, a
@c plan-authoring system for complex military operations.

@c FIXME: Add pointer to the paper about SHOP2 applications.
@c FIXME: Add pointer to the ELS 2019 paper.

@item
@sysname {} incorporates many features from
@uref{http://www.dur.ac.uk/d.p.long/IPC/pddl.html,PDDL}, e.g., support
for quantifiers and conditional effects in methods and operators.

@item
@shoptwo {} and @sysname {} (unlike @SHOP {}) allow a combination of partially ordered and fully ordered
task networks through the use of the @code{:unordered} and
@code{:ordered} keywords.

@item
@sysname {} task networks are @emph{less} expressive than full HTN
planners such as UMCP, @c FIXME -- add citation
which have labeled tasks in their task networks and allow arbitrary
ordering constraints.

@item
@sysname {} allows branch-and-bound optimization of plan costs. For small
problems, this capability can be used to find the absolute minimum cost
plans. For larger problems, this capability can be used with time limits
to get the lowest cost plan that is found within the given time limit.

@item
@sysname {} adds support for the Planner Domain Description Language
(PDDL), and updates the @SHOP {} language for easier domain engineering.

@end itemize

@node Execution Environment, Running SHOP3, Introduction, Top
@chapter Execution Environment
@anchor{#execution-environment}
@sysname {} is written in Common Lisp. To be able to run @sysname, you will need
to have Common Lisp installed on your computer. We have run @sysname{}
successfully under the following implementations of Common Lisp, and we
would be interested in hearing your reports about other implementations:

@itemize
@item
Allegro Common Lisp v. 10.x (on x86 and x86_64 Linux and Mac OSX);

@item
Steel Bank Common Lisp, v. 1.4+ on x86 and x86_64, Linux and Mac OSX.

@item
Clozure Common Lisp, version 1.11 on Mac OS X and Linux.

@c @item
@c GNU clisp, version 2.49 on Mac OS X and Linux.

@end itemize

We suspect that there may be some difficulties in running @sysname {} on
Windows; most of these have to do with getting the ASDF system
definitions to work on Windows, not with @sysname {} proper. Please contact us
if you encounter difficulties. We welcome reports of experiences with
other platforms and CL implementations, and will attempt to support
users who wish to bring @sysname {} up on other combinations.

Note that @sysname {} is known @strong{not} to work with Embeddable Common
Lisp (ECL).

@sysname {} is distributed with a system definition written using the
open-source ASDF system definition facility (for more information, see
@url{http://common-lisp.net/projects/asdf/}). You should insure that all of the .asd
files in the @sysname {} distribution can be found by ASDF, per the
instructions given with ASDF, and then @sysname {} should load without any
problems. See Section 5.1 for more details about how to load @sysname.
All of the CL implementations we know of ship with ASDF pre-installed.
To enable it you may have to
@lisp
(require :asdf)
@end lisp


@c @node Notations Used in This Document, The SHOP3 Formalism, Execution Environment, Top
@c @chapter Notations Used in This Document
@c @anchor{#notations-used-in-this-document}
@c In order to differentiate some words or expressions in the text, we used
@c the following conventions:

@c @itemize
@c @item
@c Boldface is used to indicate that a term is being defined. For
@c example:@*
@c “An @strong{axiom list} is a list of axioms intended to represent what
@c we can infer from a state.”

@c @item
@c Italic characters refer to special words or symbols. For example:@*
@c “ Let @emph{a} be a @emph{logical atom}.”

@c @item
@c Typewriter characters are used to write computer code. For example:@*
@c “(call <= 7 (call + 5 3))”

@c @item
@c Square brackets indicate that a parameter or keyword is optional. For
@c example, in the following form, the @emph{name@sub{i}}'s are optional
@c parameters and thus the form is still valid if any of the
@c @emph{name@sub{i}}'s are missing:

@c @end itemize

@c “(:- @emph{a} [@emph{name@sub{1}}] @emph{C@sub{1}} [@emph{name@sub{2}}]
@c @emph{C@sub{2}} [@emph{name@sub{3}}] @emph{C@sub{3}} @dots{}
@c [@emph{name@sub{n}}] @emph{C@sub{n}})”

@node Running SHOP3, The SHOP3 Formalism, Execution Environment, Top
@chapter Running @sysname {}
@findex find-plans
@findex find-plans-stack
@findex mk:defsystem
@findex do-problems
@findex shop-trace
@findex shop-untrace

The latest version of @sysname {} is loaded by using the ASDF system
definition facility. The first of the following subsections explains how
to use ASDF to load @sysname.@footnote{Previous methods of starting @sysname,
by hand-coded load files, and @code{mk:defsystem}, are no longer supported.}
There are three ways to invoke the @sysname {} planning process:
@code{find-plans}, and @code{find-plans-stack},
which find plans for a single planning problem, and @code{do-problems}, which
finds plans for a planning problem set.
@xref{Executing the Planner} @c Subsection 5.2
for instructions in the use
of these functions.
The functions @code{shop-trace}
and @code{shop-untrace} are the primary mechanisms for debugging @sysname{}
domain descriptions and problem specifications, @pxref{Tracing} for
instructions. @xref{Other Debugging Features} describes
some additional features that may be useful for debugging domain
descriptions and problems for @sysname. Finally, @pxref{Hook Routines}
for a description of
some hook routines that can be used to customize the behavior of @sysname.
@menu
* Loading the Planner::
* Executing the Planner::
* Tracing::
* Other Debugging Features::
* Syntax Checks::
* Debugging Suggestions::
* Hook Routines::
@end menu

@node Loading the Planner, Executing the Planner, Running SHOP3, Running SHOP3
@section Loading the Planner
@anchor{#loading-the-planner}
The @sysname {} planner should be loaded into your Lisp environment using
ASDF. Assuming that ASDF is properly installed, and the @sysname.asd system
definition file can be found by ASDF,, the following command should get
the system loaded:

@example
(asdf:load-system "shop3")
@end example

@sysname {} is defined in the @sysname {} package (and uses the @sysname.theorem-prover
package). The easiest way to use the system for experimentation will be
to change to the predefined @code{:SHOP-USER} package and work in there:

@example
(in-package :shop-user)
@end example


If you are working on a larger or more ambitious project, it will be
more appropriate for you to work in a package of your own definition,
which should, at least, @code{:use} the @code{SHOP3} and @code{COMMON-LISP} packages.

@node Executing the Planner, Tracing, Loading the Planner, Running SHOP3
@section Executing the Planner
@anchor{#executing-the-planner}

@c FIXME: Introductory paragraph goes here.



@menu
* @code{find-plans}: find-plans.
* find-plans-stack::
* @code{do-problems}: do-problems.
* Common Keyword Arguments::
@end menu

@node find-plans, find-plans-stack, Executing the Planner, Executing the Planner
@subsection @code{find-plans}
The @code{find-plans} function has one mandatory argument, the name of
a planning problem, and a set of optional keyword arguments. It
returns up to four values. @code{find-plans} will always return two
values: (1) a list of plans and (2) the total amount of CPU time used
during planning (in seconds). If the @code{:plan-tree} argument (see
below) is non-NIL, then two additional values will be returned: (3) a
list of plan tree data structures and (4) a list of final state data
structures. From the plan state data structures, the user can extract
full state trajectories for the plans.

@include include/fun-shop-find-plans.texinfo

@node find-plans-stack, do-problems, find-plans, Executing the Planner
@subsection @code{find-plans-stack}

@include include/fun-shop-find-plans-stack.texinfo

@node do-problems, Common Keyword Arguments, find-plans-stack, Executing the Planner
@subsection @code{do-problems}

The @code{do-problems} function has one mandatory argument, which can either be
the name of a planning problem set or a list of names of planning
problems. It executes @code{find-plans} on each of the given planning problems
and returns @code{nil}.

@include include/fun-shop-do-problems.texinfo

@node Common Keyword Arguments,  , do-problems, Executing the Planner
@subsection Common Keyword Arguments

@c FIXME: review the following...
The keyword arguments to @code{find-plans} and @code{do-problems} are as follows:

@itemize
@item
@var{which} says what kind of search to do. Here are its possible
values and what they mean. The default value of @var{which} is the
value of the global variable @code{*which*} (whose default value is
@code{:first}).
@vindex *which*

@multitable {@code{:all-shallowest}} {Depth-first search for the shallowest plan or the first such}
@item
@strong{Value }
 @tab @strong{Kind of search }
@item
@code{:first}
 @tab Depth first search, stopping at the first plan found
@item
@code{:all}
 @tab Depth-first search, but don't stop until all plans in
 @i{plans(S, T, M)} have been found
@item
@code{:shallowest}
 @tab Depth-first search for the shallowest plan, or the first such plan
if there is more than one of them. In many domains this is also the
least-cost plan
@item
@code{:all-shallowest}
 @tab Depth-first search for all shallowest plans in the search space
@item
@code{:id-first}
 @tab Iterative-deepening search, stopping after the first plan found
@item
@code{:id-all}
 @tab Iterative-deepening search for all shallowest plans
@end multitable

The @emph{iterative deepening} options, @code{:id-all} and
@code{:id-first}, are equivalent to taking a modified version of
@code{find-plans} that backtracks each time it reaches depth @emph{d},
and calling it repeatedly with @emph{d} = 1, 2, @dots{}, until a plan
is found.

@item
@var{verbose} says what information to print out, as shown in the
following table. The default value for @var{verbose} is 1.
@anchor{#verbose}

@multitable {3 or @code{:long-plans}} {The statistics plus a succinct version of each plan found}
@item
@strong{Value }
 @tab @strong{What to print}
@item
0 or @code{nil}
 @tab Nothing
@item
1 or @code{:stats}
 @tab Some statistics about the search
@item
2 or @code{:plans}
 @tab The statistics plus a succinct version of each plan found:
internal operators
(@pxref{#internal-operators, internal operators, internal operators}),
and operator costs are omitted.
@item
3 or @code{:long-plans}
 @tab The statistics plus the complete version of each plan found
@end multitable

@item
If @var{gc} is non-nil, then @code{find-plans} calls the garbage collector
just before starting its search, thus making it somewhat easier to get
repeatable experimental results. The default value of @var{gc} is @code{T}.

@item
If @var{pp} is non-nil, then all printing done by @sysname {} is performed
using the Common Lisp pretty-printing mechanism. This typically leads to
more easily read output. The default value of @var{pp} is @code{T}.

@item
The @var{state} argument controls how states are represented
internally. @sysname {} can have different performance characteristics
depending on the value provided to this augment. If you are encountering
out-of-memory errors in @sysname {} or you want to get the maximum speed
possible from @sysname {} for a particular set of problems, you may wish to
experiment with different values for this argument. The default value is
:mixed, which represents states using a combination of lists and hash
tables; this value has been shown to provide a reasonably good
combination of speed and memory usage on a variety of test problems. The
other values are @code{:list}, @code{:hash}, and @code{:bit}.

@item
The @var{optimize-cost} argument is used to perform planning with
branch-and-bound optimization of the total plan cost. The default value
for this argument is nil. If the value of this argument is nil, the
optimization feature is disabled. If the value of the argument is t,
@sysname {} will search for plans with the minimum total cost. If the value of
the argument is a number, @sysname {} will use the branch-and-bound technique
to search for plans with cost less than or equal to the value of the
argument. The optimization feature is written under the assumption that
the costs of operators are always non-negative. If this assumption is
invalid, @sysname {} will produce unreliable results (specifically it will
prune out some valid plans). The interaction of :optimize-cost with the
various options for :which can be subtle. Below are notes on each
possible combination:

@item @code{(:which :first :optimize-cost t)}

Under these arguments, @sysname {} returns the first plan found for which no
other valid plan has a lower total cost. Note that this option may take
much more time to run than using (:which :first :optimize-cost nil)
since even after it finds the plan, it must keep searching to see if it
can find a cheaper plan. However, this option may be significantly
faster than @code{(:which :all :optimize-cost nil)} since the branch-and-bound
mechanism will prune out non-optimal plans without having to consider
them all the way to the end. In some cases, this will mean that (:which
:first :optimize-cost t) terminates and (:which :all :optimize-cost nil)
does not.

@item
@code{(:which :first :optimize-cost @var{number})}

Under these arguments, @sysname {} returns the first plan found whose total
cost is less than or equal to the number given. If there is no plan
whose total cost is less than or equal to that number, @sysname {} will return
no plans. Note that if the number given is large enough, these arguments
can produce results much more quickly than with (:which :first
:optimize-cost t); specifically, as soon as @sysname {} finds a plan for which
the cost is met, it can terminate and does not have to keep searching
for cheaper plans.

@item
@code{(:which :all :optimize-cost t)}

Under these arguments, @sysname {} returns all plans for which no other valid
plan has a lower total cost. Obviously, all plans returned under these
options will have equal total cost.

@item
@code{(:which :all :optimize-cost @var{number})}

Under these arguments, @sysname {} returns all plans with total cost less than
or equal to the given number.

@item
@code{(:which :shallowest :optimize-cost t)}

Under these arguments, @sysname {} returns a plan that has the shallowest
depth of all valid plans and for which there is no other shallowest
depth valid plan which has a lower total cost. In other words, these
arguments produce the cheapest of all shallowest plans (which,
incidentally, is not necessarily the same thing as the shallowest of all
cheapest plans).

@item
@code{(:which :shallowest :optimize-cost @var{number})}

Under these arguments, @sysname {} returns a plan which has the shallowest
depth of all valid plans and whose total cost is less than or equal to
the given number. Note that if there is no plan whose cost is less than
or equal to the number and whose depth is shallowest among all valid
plans, then no plan will be returned (even if there are deeper plans
which do have cost less than or equal to the number).

@item
@code{(:which :all-shallowest :optimize-cost t)}

Under these arguments, @sysname {} returns all plans which have the shallowest
depth of all valid plans and for which there is no other shallowest
depth valid plan which has a lower total cost.

@item
@code{(:which :all-shallowest :optimize-cost @var{number})}

Under these arguments, @sysname {} returns all plans which have the shallowest
depth and whose total cost is less than or equal to the given number.

@item
@code{(:which :id-first)} or @code{(:which :id-all)}

The @code{:id-first} and @code{:id-all} options produce the same results
as the @emph{shallowest} and @emph{all-shallowest} arguments,
respectively for each different combination with @code{:optimize-cost}. Note,
however, that there are domains for which @sysname {} will terminate using
@emph{id-first} and @emph{id-all} and will not terminate using other
values for @code{:which}.

@item
The @var{time-limit} argument may either nil or a number. Its default
is nil and if it is nil, no time limit is imposed on the planning
process. If the @var{time-limit} argument is a number, @sysname {} will check
the elapsed CPU time at the start of each step of the planning process,
and if the number of seconds elapsed is greater than the argument value,
@sysname {} will immediately terminate. The main use for this feature is in
combination with @code{(:optimize-cost t)} argument, in order to return the
optimal value found within the given time limit. For example, consider
the call @code{(find-plans 'foo :verbose 1 :optimize-cost t :time-limit 120)}.
This call addresses a problem named @emph{foo}, and runs until it either
finds the minimum cost plan or until 2 minutes have elapsed. It then
returns the lowest cost plan that it found during that time. This
functionality is inspired, in part, by Anytime Algorithms
(@pxref{DeanBoddy1998, Dean & Boddy@comma{} 1998}).

@item @anchor{#explanation}
If @emph{explanation} is non-nil, @sysname {} adds extra information
at the end of each operator explaining how the preconditions for that
operator were satisfied. Currently supports only logical atoms,
@code{and}, and @code{or}; it doesn't work with @code{forall},
@code{not}, @code{eval}, etc. If this feature is used with the
external-access-hook feature (see @ref{Hook Routines}), any attribution
information provided by the external-access-hook routine is included
in the relevant explanation. The default value of @emph{explanation}
is @code{nil}.
@cindex explanation

@item
The @emph{plan-tree} argument defaults to nil; if true, the planner will
return two additional values: (1) a list of complete task decomposition
trees for the plans and (2) a list of plan state data structures
corresponding to the final states of each plan. Plan trees are encoded
in a nested list format in which the decomposition of an upper level
task into lower level tasks is represented by the upper level task atom,
followed by trees for each lower level task. The leaves of the tree,
involving operators, are each lists of three elements: the cost of the
operator, the task atom for the operator, and the numerical position of
the operator in the plan (starting at 1). For example, a task @code{(travel
houston springfield)} that was directly decomposed into operators, @code{(!fly
houston boston)} with cost 200 and @code{(!drive boston springfield)} with cost
50, would have the following plan tree:

@lisp
((travel houston springfield)
 (200 (!fly houston boston) 1)
 (50 (!drive boston springfield) 2))
@end lisp

@end itemize


@node Tracing, Other Debugging Features, Executing the Planner, Running SHOP3
@section Tracing
@findex shop-trace
@findex shop-untrace
There are two functions used for controlling the tracing mechanism in
@sysname: @code{shop-trace} and @code{shop-untrace}. These are similar to Lisp's trace
and untrace functions. Once they have been invoked, subsequent calls to
@code{find-plans} or @code{do-problems} will print out information about elements of
the domain for which tracing is enabled whenever those elements are
encountered. More specifically:

@itemize
@item @code{(shop-trace @var{item})}
will turn on tracing for @var{item}, which may be any
of the following:
@itemize
@item
a method, axiom, operator, task, or goal;
@item
one of the keywords @code{:methods}, @code{:axioms},
@code{:operators}, @code{:tasks}, @code{:goals}, or
@code{:protections} in which case @sysname{} will trace @emph{all}
items of that type (@code{:goals} refers to predicates that are goals
for the theorem-prover, and @code{:protections} refers to predicates
used as arguments of @code{:protection} in operators);
@item
the keyword @code{:states}, in which case @sysname{} will include the current state
whenever it prints out a tracing message
@item
the keyword @code{:plans} in which case @sysname{} will print diagnostic information
whenever it has found a plan (and may be considering whether or not to
keep the plan, depending on the @code{:which} and @code{:optimize} arguments of
@code{seek-plans}).
@item
The keyword @code{:all}, which will trace all available items, currently
methods, axioms, operators, tasks, goals and protections.
@end itemize

@item
@code{(shop-trace @emph{item1 item2} @dots{})}
 will do the same for a list of items
@item
@code{(shop-trace)} will print a list of what's currently being traced
@item
@code{(shop-untrace @emph{item})} will turn off tracing for an item
@item
@code{(shop-untrace @emph{item1 item2} @dots{})} will turn off tracing for a list
of items
@item
@code{(shop-untrace)} will turn off tracing for all items
@end itemize

@include include/macro-shop-shop-trace.texinfo

@node Other Debugging Features, Syntax Checks, Tracing, Running SHOP3
@section Other Debugging Features
@vindex *current-state*
@vindex *current-plan*
@vindex *current-tasks*
@vindex *break-on-backtrack*
@findex print-current-state
@findex print-current-plan
@findex print-current-tasks

There are three variables, namely @var{*current-state*}, @var{*current-plan*}, and
@var{*current-tasks*}, in @sysname{}. These variables can be used to monitor the
current status of the state, current plan and the list of current tasks
to be accomplished respectively. Since these are the internal variables
of the @sysname {} planning system, the following functions are defined to
access the current contents of those variables: @code{print-current-state},
@code{print-current-plan}, and @code{print-current-tasks}, respectively. Note that
these are Lisp functions that must be called by using the Lisp
evaluator. The best way to use these functions is to define dedicated
methods in the domain that invoke the functions using @code{eval} or @code{call}
expressions in their predicates. Those methods can then be used in the
problem definition where debugging output is needed. For example, the
following methods can be included in any domain description for this
purpose:

@lisp
(:method (print-current-state)
    ((eval (print-current-state)))
    ())

(:method (print-current-tasks)
   ((eval (print-current-tasks)))
   ())

(:method (print-current-plan)
    ((eval (print-current-plan)))
    ())
@end lisp


And these special purpose methods can be used in the task decompositions
of other methods for debugging purposes. For example,

@lisp
(:method
    (do-both ?x ?y)
    nil
    (:ordered
      (:task !do ?y)
      (:task print-current-state)
      (:task !do ?x))))
@end lisp

@vindex *break-on-backtrack*
There is now a new variable, @var{*break-on-backtrack*}, that will cause the
Lisp environment to throw into a break loop when @sysname {} backtracks.

@node Syntax Checks, Debugging Suggestions, Other Debugging Features, Running SHOP3
@section Syntax Checks

@cindex singleton variables
@cindex anonymous variables

We have adopted for @sysname {} the “singleton variable” check common in
Prolog implementations. Logic variables are used to express unification
constraints on expressions. In practice, a singleton logical variable in
a @sysname {} expression (a method, operator, or axiom definition) is often a
typographical error. Accordingly, @sysname {} will issue a warning when it
encounters a logical variable used only once. If the single use is
correct, the proper (and nicely self-documenting) way to disable this
warning is to use an @emph{anonymous variable} (see @pxref{Symbols}).

@node Debugging Suggestions, Hook Routines, Syntax Checks, Running SHOP3
@section Debugging Suggestions
@anchor{#debugging-suggestions}
When you have a problem that does not solve as expected, the following
general recipe may help you home in on bugs in your domain definition:

@enumerate
@item
Start by doing @code{(shop-trace :tasks)} and then try @code{find-plans} again.

@item
In many cases, the domain will be written so that there will be little
or no backtracking. In this case, examine the output of the traced call
to @code{find-plans} and look for the first backtracking point.

@item
The above process should help you identify a particular task, either a
primitive or a complex task, as a likely problem spot. If it's a
primitive task, the next step is to examine the operator definition. If
it's a complex task, you should check the method definitions. If you
have any trouble identifying which method definition is relevant, you
can use @code{(shop-trace :methods)} to further focus your attention.

@item
If visual inspection of method and operator definitions does not reveal
the problem, you most likely have problems with precondition
expressions. In this case, try using @code{(shop-trace :goals)}, re-running
@code{find-plans} and check to see what's happened when your problematic method or
operator's preconditions are checked.

@end enumerate

This recipe has proven effective for finding the vast majority of bugs
in @sysname {} domains.

@node Hook Routines,  , Debugging Suggestions, Running SHOP3
@section Hook Routines
@cindex hook-routines
@sysname {} recognizes several different hook routines. These are Lisp
routines that may be defined by the user; if they are defined, they are
invoked under specific circumstances. Hook routines are typically used
when embedding @sysname {} in an application; they allow such an application
to obtain additional information from @sysname {} or to affect its behavior.
There are three hooks that are recognized by @sysname:

@itemize
@item
@code{(plan-found-hook state which plan cost depth)}
@findex plan-found-hook
If this routine is defined, @sysname {} invokes it whenever it finds a plan.
It can be useful for displaying and/or recording details about the plan.
The arguments are the current state, the value for the :which argument
that was provided to the planner, the plan, the cost of the plan, and
the search depth at which the plan was found.
@item
@code{(trace-query-hook type item additional-information state-atoms)}
@findex trace-query-hook
If this routine is defined, @sysname {} invokes it whenever it invokes the
@c FIXME: fix cross-reference
tracing mechanism (@pxref{Tracing}). The arguments include the type of
item being traced (e.g., @code{:task}, @code{:method}), the item, the list of Lisp
values that are printed by the tracing mechanism, and a list of logical
atoms in the current state.
@item
@code{(external-access-hook query)}
@findex external-access-hook
This hook routine is intended to allow @sysname {} to use an external source
(such as a database) to determine the applicability of methods and
operators. To use this hook routine, a domain must include one or more
logical expressions that have the keyword @code{:external} as the first symbol.
Such expressions must only involve a single logical atom, or a single
conjunction of logical atoms. When @sysname {} attempts to find a binding that
satisfies such an expression, it will first invoke @code{external-access-hook}
to satisfy the expression; if that routine is undefined or returns nil,
@sysname {} will then try to satisfy the expression using its internal
knowledge state. The argument to @code{external-access-hook} is a list
of the form @code{'(and (@var{pred} @var{v1} @var{v2})@dots{})}.  It
returns a list of responses, each of which is a list of two elements:
an attribution, and a list of bindings for the unbound variables in the
query. The attribution is stored for use with the @emph{explanation}
option for the planning system (@pxref{#explanation, explanation,
explanation}). For example, consider a method that has the following
precondition:

@lisp
(or (and (clear ?b1) (clear ?b2) (clear ?b3))
         (:external and (on ?b1 ?b2) (on ?b2 ?b3)))
@end lisp

When this precondition is encountered and @code{external-access-hook} is
defined, @sysname {} invokes that routine with the argument @code{'(and (on ?b1 ?b2)
(on ?b2 ?b3))}. The routine might (for example) return the list:

@lisp
'((database-123 ((?b1 block10) (?b2 block 11) (?b3 block 12)))
  (database-223 ((?b1 block20) (?b2 block 21) (?b3 block 22))))
@end lisp
@end itemize



@node The SHOP3 Formalism, PDDL Support, Running SHOP3, Top
@chapter The @sysname {} Formalism
The inputs to @sysname {} are a @emph{planning domain} and either a single
@emph{planning problem} or a @emph{planning problem set}. Planning
domains are composed of @emph{operators}, @emph{methods}, and
@emph{axioms}. Planning problems are composed of @emph{logical atoms}
(an initial state) and @emph{tasks lists} (high-level actions to
perform). Planning problem sets are composed of planning problems.

The components of a planning domain (operators, methods, and axioms) all
involve @emph{logical expressions}. These logical expressions combine
@emph{logical atoms} through a variety of forms (e.g., conjunction,
disjunction). Logical atoms involve a @emph{predicate symbol} plus a
list of @emph{terms}. Task lists in planning problems are composed of
@emph{task atoms}. The components of domains and problems are all
ultimately defined by various @emph{symbols}.

This section describes each of the aforementioned structures. It is
organized in a bottom-up manner because the specification of
higher-level structures is dependent on the specification of lower-level
structures. For example, methods are defined after logical expressions
because methods contain logical expressions.
@menu
* Symbols::
* General Lisp Expressions::
* Terms::
* Logical Atoms ::
* Logical Expressions::
* Logical Precondition::
* Axioms::
* Task Atoms::
* Task Lists::
* Operators::
* Methods::
* Planning Domain::
* Planning Problem::
* Planning Problem Set::
* Plans::
* Simple example::
@end menu

@node Symbols, General Lisp Expressions, The SHOP3 Formalism, The SHOP3 Formalism
@section Symbols
@anchor{#symbols}
In the structures defined below, there are five kinds of symbols:
@strong{variable} symbols, @strong{constant} symbols, @strong{function}
symbols, @strong{primitive task} symbols, and @strong{compound task}
symbols. To distinguish among these symbols, SHOP and @sysname {} both use
the following conventions:

@itemize
@item
a @strong{variable} symbol can be any Lisp symbol whose name begins with
a question mark (such as @code{?x} or @code{?hello-there})

@item
an @strong{anonymous variable} symbol can be any variable symbol with an
underscore immediately following the question mark in its name (such as
@code{?_} or @code{?_airplane}). These variables will unify with any value, and need
not co-refer (i.e., two copies of @code{?_} in a single term need not unify
with each other). These variables will also not trip the singleton
variable check.

@item
a @strong{primitive task} symbol can be any Lisp symbol whose name
begins with an exclamation point (such as @code{!unstack} or @code{!putdown})

@item
a @strong{constant} symbol, a @strong{function} symbol, a
@strong{predicate} symbol, or a @strong{compound task} symbol can be
any Lisp symbol whose name does not begin with a question mark or
exclamation point. We use ``predicate'' and ``function'' in the
first-order logic sense; as will be seen in @ref{Eval Terms}, the
functions can be general Lisp functions.

@end itemize

Any of the structures defined in the remaining sections are said to be
@strong{ground} if they contain no variable symbols.

@node General Lisp Expressions, Terms, Symbols, The SHOP3 Formalism
@section General Lisp Expressions
@anchor{#general-lisp-expressions}

A number of @sysname {} domain structures described in this section,
(e.g. @ref{Assignments}, @ref{Sorted Precondition}, @ref{Eval Terms},
and @ref{Call Terms}) use @strong{general Lisp expressions}.  These
are arbitrary pieces of Lisp code which can include functions, macros,
special macro symbols (e.g., backquote), etc. When @sysname {} needs
to get the value of a general Lisp expression, it first substitutes
values for any variable symbols in the expression that are bound. Then
it submits the entire expression to the Lisp environment to get its
value.

@strong{Note:} Counter-intuitive bugs may arise when symbols are passed
to Lisp for evaluation (either as constants or as the values of
variables). Remember that the Lisp evaluator will assume that these are
variables! If you wish them to be treated as symbols, you will need to
quote them. This leads to a slightly undesirable oddity --- variables
that will be bound to, for example, numbers, can appear normally.
Variables that will be bound to symbols will have to be
quoted. @xref{Eval Terms, eval terms}.

@node Terms, Logical Atoms , General Lisp Expressions, The SHOP3 Formalism
@section Terms
@anchor{#terms}
A @strong{term} is any one of the following:

@itemize
@item
a variable symbol

@item
a constant symbol

@item
a number

@item
a @strong{list term}

@item
an @strong{eval term}

@item
a @strong{call term}

@end itemize
@noindent
The last two are @emph{function} terms in first-order logic parlance.

@menu
* List Terms::
* Eval Terms::
* Call Terms::
@end menu

@node List Terms, Eval Terms, Terms, Terms
@subsection List Terms
@anchor{#list-terms}
A @strong{list term} is a term having the form

@lisp
([@var{list}] @var{t@sub{1}} @var{t@sub{2}} @dots{} @var{t@sub{n} [. @var{l}]})
@end lisp

@noindent
where @var{list} is an optional reserved word and each @var{t@sub{i}}
is a term. This specifies that @var{t@sub{1}} @var{t@sub{2}} @dots{}
@var{t@sub{n}} are the items of a list. If the final, optional element
is included, the item @var{l} should evaluate to a list; all items in
@var{l} are included in the list after @var{t@sub{1}} through
@var{t@sub{n}}.

@node Eval Terms, Call Terms, List Terms, Terms
@subsection Eval Terms
@anchor{#eval-terms}
An @strong{eval} term is an expression of the form

@lisp
(eval @emph{general-lisp-expression})
@end lisp
The @emph{value} associated with an @code{eval} term is determined as follows. First,
any variable symbols which appear in @var{general-lisp-expression} and are
bound are replaced by the values that they are bound to. Then, the
entire expression is evaluated in Lisp. For example, if the variable
symbol @var{?foo} is bound to the value 3 then the term:

@lisp
(eval (mapcar #'(lambda (x) (+ x ?foo)) `(1 2 ,(* ?foo ?foo))))
@end lisp
@noindent
will have as its value a list containing the numbers 4, 5, and 12.

@cindex quoting in call and eval terms
Note that variable substitutions in @code{eval} terms are handled
before any evaluation of the expression, as in Lisp macros. One
implication of this fact is that variables with symbolic values must
be explicitly quoted if they are to be treated as Lisp symbols. For
example, if the variable @var{?foo} is bound to the symbol @code{bar},
the following @code{eval} term has the value @code{(bar baz)}:

@lisp
(eval (list '?foo 'baz))
@end lisp
@noindent
But if this were written

@lisp
(eval (list ?foo 'baz))
@end lisp
@noindent
it would cause a Lisp error when Lisp attempts to find the value of @code{bar},
which it would believe to be a variable.

@node Call Terms,  , Eval Terms, Terms
@subsection Call terms
@anchor{#call-terms}
A @strong{call} term is not as expressive as an @code{eval} term. In
particular, it does not support the evaluation of Lisp macros
(including macro characters such as backquote). Both @code{call} and
@code{eval} are supported in @sysname {} because the former is
compatible with JSHOP 1.0 and the latter is compatible with SHOP
1.x. @sysname {} users who are not interested in either form of
compatibility may use either form.

A @strong{call} term is an expression of the form

@lisp
(call @var{f} @var{t@sub{1}} @var{t@sub{2}} @dots{} @var{t@sub{n}})
@end lisp
@noindent
where @var{f} is a function symbol and each @var{t@sub{i}} is a term
or a @code{call} term. A @code{call} term has a special meaning to @sysname, because it
tells @sysname {} that @var{f} is an attached procedure, i.e., that whenever
@sysname {} needs to evaluate a precondition or task list that contains a
@code{call} term, @sysname {} should replace the @code{call} term with the result of
applying the function @var{f} to the arguments @var{t@sub{1},
t@sub{2}, @dots{}, t@sub{n}}.  We later will define preconditions
(@pxref{Logical Precondition, preconditions}) and task lists
(@pxref{Task Lists}).

For example, the following @code{call} term would have the value 6:

@lisp
(call + (call + 1 2) 3)
@end lisp


@node Logical Atoms , Logical Expressions, Terms, The SHOP3 Formalism
@section Logical Atoms
@anchor{#logical-atoms}
A @strong{logical atom} has the form:

@lisp
(@var{p} @var{t@sub{1}} @var{t@sub{2}} @dots{} @var{t@sub{n}})
@end lisp
@noindent
where @var{p} is a predicate symbol, each @var{t@sub{i}} is a term
other than an @code{eval} or @code{call} term, and @math{n} can be 0.

@node Logical Expressions, Logical Precondition, Logical Atoms , The SHOP3 Formalism
@section Logical Expressions
@anchor{#logical-expressions} A @strong{logical expression} is a
logical @strong{atom} or any of the following complex expressions:
@strong{conjuncts}, @strong{disjuncts}, @strong{negations},
@strong{implications}, @strong{universal quantifications},
@strong{assignments}, @strong{eval}, @strong{call}, @strong{enforce},
@strong{setof}, and @strong{bagof}.  @emph{Terms} enter into
logical expressions via atoms.
@menu
* Conjuncts::
* Disjuncts::
* Negations::
* Implications::
* Universal Quantifications::
* Assignments::
* Eval expressions::
* call expressions::
* Enforce expressions::
* Setof expressions::
* Bagof expressions::
@end menu

@node Conjuncts, Disjuncts, Logical Expressions, Logical Expressions
@subsection Conjuncts
@anchor{#conjuncts}
A @strong{conjunct} has the form

@lisp
([and]@emph{l@sub{1}} @emph{l@sub{2}} @dots{} @emph{l@sub{n}})
@end lisp

@noindent
where each @emph{l@sub{i }} is a logical expression.

Note that if there
are 0 conjuncts (e.g., the expression is ()) then the form always
evaluates to true.

@cindex implicit conjunction
Also note that @emph{implicit conjunction} (list of logical expressions
without an explicit @code{and}) is @strong{deprecated}, and will
eventually be removed, as it significantly complicates @sysname{}'s
parsing -- and reading @sysname{} code by humans.

@node Disjuncts, Negations, Conjuncts, Logical Expressions
@subsection Disjuncts
@anchor{#disjuncts}
A @strong{disjunct} is an expression of the form

@lisp
(or @var{l@sub{1}} @var{l@sub{2}} @dots{} @var{l@sub{n}})
@end lisp
@noindent
where @var{l@sub{1}}, @var{l@sub{2}} @dots{} @var{l@sub{n}} are logical
expressions.

@node Negations, Implications, Disjuncts, Logical Expressions
@subsection Negations
@anchor{#negations}
A @strong{negation} is an expression of the form

@lisp
(not @emph{l})
@end lisp
@noindent
where @emph{l} is a logical expression.

@node Implications, Universal Quantifications, Negations, Logical Expressions
@subsection Implications
@anchor{#implications}
An @strong{implication} is an expression of the form

@lisp
(imply @emph{Y Z})
@end lisp
@noindent
where @var{Y} and @var{Z} are logical expressions. The intent of an
implication is to evaluate its logical counterpart; that is,
@math{\neg Y \lor Z}.
Note that the context should not leave free variables in
@var{Y}, or the semantics of the implication will be ambiguous.

@node Universal Quantifications, Assignments, Implications, Logical Expressions
@subsection Universal Quantifications
@anchor{#universal-quantifications}
A @strong{universal quantification} expression is an expression of the
form

@lisp
(forall @emph{V E@sub{1} E@sub{2}})
@end lisp
@noindent
where @var{E@sub{1}} and @var{E@sub{2}} are logical expressions, and
@var{V} is the list of variables in @var{E@sub{1}}. To satisfy a
universally quantified expression, the following must hold:
for each possible substitution @var{u} for variables in @var{V}, if
@var{E@sub{1}@sup{u}} is satisfied then @var{E@sub{2}@sup{u}} must
also be satisfied in the current state of the world. Note that this
use of the keyword @code{forall} is distinct from its use in
@code{add} and @code{delete} lists in operators (@pxref{Operators}):
the latter is used to express a set of effects rather than a logical
expression and consequently has a different syntax.

There is no need for @strong{existential} quantifications.
See [Ghallab @emph{et al.}, 2004] or @ref{Internal Knowledge Structures}.


@node Assignments, Eval expressions, Universal Quantifications, Logical Expressions
@subsection Assignments
@cindex assignment
@anchor{#assignments}
A simple @strong{assignment} expression has the form

@lisp
(assign @var{v} @var{e})
@end lisp
@noindent
where @var{v} is a variable symbol and @var{e} is general Lisp
expression. The intent of an assignment expression is to bind the
value of @var{e} to the variable symbol @var{v}. Variable
substitutions in assignment expressions are done using literal
substitutions, as with @code{eval} terms (see @ref{Eval Terms}). For
example, if @var{?foo} is bound to the symbol @code{if} and @var{?bar}
is bound to the number 0 then the following expression will bind the
variable @var{?baz} to the list @code{(if fish)}:

@lisp
(assign ?baz (?foo (< ?bar 3) (list '?foo 'fish) (/ 8 ?bar)))
@end lisp
@noindent
Similarly, if @var{?foo} is bound to @code{list} and @var{?bar} is bound to @code{4} then the
expression above will bind @var{?baz }to the list @code{(nil (list
fish) 2)}.@footnote{
A somewhat cumbersome way to verify this is as follows:
@lisp
(defdomain test-domain ((:- (= ?x ?x) ())))
(query '((= ?foo list)
            (= ?bar 4)
            (assign ?baz (?foo (< ?bar 3) (list '?foo 'fish) (/ 8 ?bar))))
        (shop::make-initial-state 'test-domain :mixed nil)
        :domain 'test-domain)
@end lisp
}

@b{Note:} @code{assign} is @emph{not} the default way to bind
@sysname{}'s logical variables.  The default way to bind logical
variables is through @emph{unification}. @code{assign} is specifically for use
when you wish to use @emph{Lisp code} to produce values you will bind
variables to.  To that end, @code{assign} expects that its second
argument will be a Lisp expression and it will @emph{evaluate} that
expression.  It is because of this evaluation process that the following
expression (with @code{=} interpreted as unification)

@lisp
(= ?x foo)
@end lisp
@noindent
will bind @var{?x} to the symbol @code{foo}, but

@lisp
(assign ?x foo)
@end lisp
@noindent will cause a run-time error.  In the second example, @sysname
will attempt to evaluate @var{foo} and report it as an unbound variable --
unless this is evaluated in a context where @var{foo} is a variable,
in which case @var{?x} will be bound to the current value of @var{foo}.

@sysname {} also offers a @strong{compound assignment} expression of this
form:

@lisp
(assign* @var{v} @var{e})
@end lisp
@noindent

As in the simple @code{assign}, @var{v} is a variable symbol and @var{e} is
general Lisp expression. However, for @code{assign*}, @var{e} should evaluate
to a @emph{list} of possible values and through backtracking, @sysname's
theorem-prover will find all solutions with @var{v} bound to the
various values of @var{e} in turn.

@node Eval expressions, call expressions, Assignments, Logical Expressions
@subsection Eval expressions
@anchor{#eval-expressions}
An @strong{eval} expression has the same form as an @code{eval} term
(@pxref{Eval Terms}). Unlike an @code{eval} term, however, an
@code{eval} expression is interpreted simply as either true or false rather
than having some value which would be used as an argument to a
predicate. Thus an @code{eval} expression typically invokes boolean Lisp functions
such as @code{evenp} or @code{>=}.

Note that if you use an @code{eval} expression for its @emph{side effects}, you
must be careful to ensure that it still returns a true value.  For
example, if you introduce an invocation of @code{format} for debugging
purposes, remember that @code{format} always returns @code{nil}, and
will cause the containing precondition to fail!

@node call expressions, Enforce expressions, Eval expressions, Logical Expressions
@subsection Call expressions
A @strong{call} expression has the same form as a @code{call} term
(@pxref{Call Terms}). As with @code{eval} expressions (@pxref{Eval expressions}),
@code{call} expressions are interpreted as either true or false, and the
warning mentioned there about using @code{eval} expressions for side effects
applies to @code{call} expressions, as well.

@node Enforce expressions, Setof expressions, call expressions, Logical Expressions
@subsection Enforce expressions
@anchor{#enforce-expressions}
An @strong{enforce} expression has the form

@lisp
(enforce @emph{t@sub{1}} &rest @emph{error-args})
@end lisp
Enforce expressions are for goals that should @emph{always} be
satisfied. @sysname{}'s theorem-prover will attempt to prove @var{t@sub{1}} and if
it fails, will call error with @emph{error-args.} For example

@lisp
(enforce (x-position ?aircraft)
          "~A x-position undefined." (quote ?aircraft))
@end lisp

Enforce expressions are useful when debugging domains.

@node Setof expressions, Bagof expressions, Enforce expressions, Logical Expressions
@subsection Setof expressions
@anchor{#setof-expressions}
A @strong{setof} expression has the form

@lisp
(setof @emph{term expr set-var})
@end lisp
Find all solutions to @var{expr}, and bind the @emph{set} of values for
@var{term} in @var{expr} to @var{set-var}. For example

@lisp
(setof ?u (uav ?u) ?uavs)
@end lisp
@noindent
will bind @var{?uavs} to the set of UAVs in the current state.

@lisp
(setof (pair ?u1 ?u2)
  (and (uav ?u1) (uav ?u2) (line-of-sight ?u1 ?u2))
  ?pairs)
@end lisp
@noindent
will bind @var{?pairs} to a set of terms, e.g., @code{((pair rotor1
fw2) (pair rotor2 fw3))} indicating pairs of UAVs with line of sight
from the first to the second.

@b{Note:} The semantics of @code{setof} are to @emph{fail} if the
@var{expr} is an unsatisfiable goal.

@b{Note:} Support for general terms as the first argument to
@code{setof} and @code{bagof} (@pxref{Bagof expressions}) is new in
version 3.4 of @sysname{}.  Code that depends on it should use a
corresponding version dependency qualifier in, e.g., ASDF (@code{(:version "shop3" "3.4")}).

@node Bagof expressions,  , Setof expressions, Logical Expressions
@subsection Bagof expressions
@anchor{#bagof-expressions}
The syntax for @code{bagof} is the same as for @code{setof} (Section 4.5.10), but
binds @emph{set-var} to a @emph{bag} of results, which may contain
duplicates, instead of a set.

@node Logical Precondition, Axioms, Logical Expressions, The SHOP3 Formalism
@section Logical Precondition
@anchor{#logical-precondition}
A @strong{logical precondition} is either a logical expression or one of
the following special precondition forms: @strong{first satisfier}
precondition, @strong{sorted} precondition.
@menu
* First Satisfiers Precondition::
* Sorted Precondition::
@end menu

@node First Satisfiers Precondition, Sorted Precondition, Logical Precondition, Logical Precondition
@subsection First Satisfiers Precondition
@anchor{#first-satisfiers-precondition}
A @strong{first satisfier} precondition has the form

@lisp
(:first @emph{l@sub{1} l@sub{2} @dots{} l@sub{n}})
@end lisp
@noindent
where each @var{l@sub{i }} is a logical expression. Such a precondition
causes @sysname {} to consider only the first set of bindings that satisfies
all of the given expressions. Alternative bindings will not be
considered even if the first bindings found do not lead to a valid plan.

@node Sorted Precondition,  , First Satisfiers Precondition, Logical Precondition
@subsection Sorted Precondition
@anchor{#sorted-precondition}
A @strong{sorted precondition} has the form

@lisp
(:sort-by @emph{?v [e] l})
@end lisp
@noindent
where @var{?v} is a variable symbol, @var{e} is a general Lisp
expression (which should evaluate to a comparison function), and
@var{l} is a logical expression. Such a precondition causes @sysname
{} to consider bindings for @var{?v} in a specific order: bindings are
sorted such that if the comparison function holds between values
@var{x} and @var{y} then bindings of @var{?v} to @var{x} may not occur
after bindings of @var{?v} to @var{y}. For example consider the
precondition:

@lisp
(:sort-by ?d #'> (and (at ?here) (distance ?here ?there ?d)))
@end lisp


This precondition will cause @sysname {} to consider bindings in decreasing
(high to low) order of the value of @emph{?d}. If the comparison
function (@emph{e}) is omitted, it defaults to #'<, indicating
increasing (low to high) order.

@node Axioms, Task Atoms, Logical Precondition, The SHOP3 Formalism
@section Axioms
@anchor{#axioms}
An @strong{axiom} is an expression of the form

@lisp
(:- a
    [name@sub{1}] @var{E@sub{1}}
    [name@sub{2}] @var{E@sub{2}}
    [name@sub{3}] @var{E@sub{3}} @dots{}
    [name@sub{n}] @var{E@sub{n}})
@end lisp
@noindent
where the axiom's @strong{head} is a logical atom @var{a}, and its
@strong{tail} is the list ([@var{name@sub{1}}] @var{E@sub{1}}
[@var{name@sub{2}}] @var{E@sub{2}} [@var{name@sub{3}}] @var{E@sub{3}}
@dots{} [@var{name@sub{n}}] @var{E@sub{n}}).  Each @var{E@sub{i}} is a
logical expression and @var{name@sub{i}} is a symbol called the
@emph{name} of @var{E@sub{i}}. These names are optional; when a domain
definition is loaded into @sysname, a unique name will be generated
for each @var{E@sub{i}} if no name was given.  The names have no
semantic meaning to @sysname, but are provided to help the user debug
domain descriptions by looking at traces of @sysname's behavior.

The intended meaning of an axiom is that @var{a} is true if
@var{E@sub{1}} @math{\vee \cdots \vee} @var{E@sub{n}}, and the
evaluation stops when, for @math{i=1,2,\ldots}, the first true
@var{E@sub{i}} is encountered.

For example, the following axiom says that a location is in walking
distance if the weather is good and the location is within two miles
of home, or if the weather is not good and the location is within one
mile of home:

@lisp
(:- (walking-distance ?x)
     good (and (weather-is good) (distance home ?x ?d) (call <= ?d 2))
     bad  (and (distance home ?x ?d) (call <= ?d 1)))
@end lisp
There is more to be said on axioms: see @ref{More on axioms}.


@node Task Atoms, Task Lists, Axioms, The SHOP3 Formalism
@section Task Atoms
@anchor{#task-atoms}
A @strong{task atom} is an expression of any of the forms

@lisp
(@emph{s} @emph{t@sub{1}} @emph{t@sub{2}} @dots{} @emph{t@sub{n}})
(:task @emph{s} @emph{t@sub{1}} @emph{t@sub{2}} @dots{} @emph{t@sub{n}})
(:task :immediate @emph{s} @emph{t@sub{1}} @emph{t@sub{2}} @dots{} @emph{t@sub{n}})
@end lisp
@noindent
where @emph{s} is a task symbol and the arguments @emph{t@sub{1},
t@sub{2}, @dots{}, t@sub{n}} are terms. The task atom is
@strong{primitive} if @emph{s} is a primitive task symbol, and it is
@strong{compound} if @emph{s} is a compound task symbol; recall
@ref{Symbols}, and also see @ref{Operators}. The first and second
forms are called an @strong{ordinary task atom}; the third form is
called an @strong{immediate task atom}. The purpose of the
@code{:immediate} keyword is to give a higher priority to the task, as
described in the following subsection.

@node Task Lists, Operators, Task Atoms, The SHOP3 Formalism
@section Task Lists
@anchor{#task-lists}
A @strong{task list} is any of the following:
@itemize
@item
an expression of the form @code{(:unordered @var{tasklist@sub{1}
tasklist@sub{2} @dots{} tasklist@sub{n}})}, where @var{tasklist@sub{1}
tasklist@sub{2} @dots{} tasklist@sub{n}} are task lists;
@item
an expression of the form @code{([:ordered] @var{tasklist@sub{1}
tasklist@sub{2} @dots{} tasklist@sub{n}})}, where @var{tasklist@sub{1}
tasklist@sub{2} @dots{} tasklist@sub{n}} are task lists.
@item
A task atom, see @ref{Task Atoms}.

@end itemize

The @code{:ordered} keyword, which is optional, specifies
that @sysname {} must perform the task lists in the order that they
are given. The @code{:unordered} keyword specifies that there is no
particular ordering specified between @var{tasklist@sub{1},
tasklist@sub{2} @dots{} tasklist@sub{n}.@ } With the use of the
@code{:unordered} keyword, @sysname {} may interleave tasks between
different task lists.  The @code{:ordered} and @code{:unordered}
keywords may be used to specify a @emph{simple task network}
(@pxref{GhallabEtAl2004}).

Now suppose that we have the following two task lists
@var{T} = @code{(:ordered @var{t}@sub{1} @var{t}@sub{2} @dots{}
@var{t@sub{m}})},

@var{U} = @code{(:ordered @var{u}@sub{1} @var{u}@sub{2} @dots{}
@var{u@sub{n}})},

@noindent and the main task list

@emph{M} = @code{(:unordered @var{T U} ).}

If none of the tasks have the @code{:immediate} keyword, then the tasks in
@var{T} should be performed in the order given, and the tasks in
@var{U} should also be performed in the order given---but it is
permissible for @sysname {} to interleave the tasks of @var{T} and the tasks
of @var{U}. However, if some of the tasks are immediate, then each time
@sysname {} chooses the next task to accomplish, it needs to give a higher
priority to the immediate tasks. For example, if @var{t}@sub{1} is
immediate and @var{u}@sub{1} is not immediate, then @sysname {} should
perform @var{t}@sub{1} before both @var{t}@sub{2} and @var{u}@sub{1}.

@strong{Note:} A task with the @code{:immediate} keyword specifies that this task must
be performed immediately when it has no predecessors.@  Therefore, we
can allow only one task with the @code{:immediate} keyword in the list of tasks
that have no predecessors.@  Otherwise @sysname's behavior on those tasks
is undefined.@  In other words, it is not allowed to have two tasks in
an @code{:unordered} list with both having the @code{:immediate} keyword.@
@ For instance, in the example above @var{t@sub{1}} and @var{u@sub{1}}
cannot both have the @code{:immediate} keyword.

@node  Operators, Methods, Task Lists, The SHOP3 Formalism
@section  Operators
@anchor{#operators}

An @strong{operator} is description of how to perform a @emph{primitive}
task, which cannot be decomposed further. An operator definition has the
following form:

@lisp
(:op @emph{head}
       [:precond @emph{precondition}]
       [:delete @emph{delete-list}]
       [:add @emph{add-list}]
       [:cost @emph{cost-fn}])
@end lisp

@noindent
where

@itemize
@item
@var{head} (the operator's @strong{head}) is a primitive task atom, i.e.
a task atom with a task symbol that begins with an exclamation point.

@item The operator's
@var{precondition} is a logical expression. This is quite general:
recall @ref{Logical Expressions}, especially @ref{Assignments}, and
@ref{Eval expressions}.  With the latter two one can, for example,
compute values for auxiliary variables, which can be used later in the
body of the operator.

@item
The operator's
@var{add-list} is a list for which each element may be any of following:

@itemize
@item
a logical atom (recall @ref{Logical Atoms}),

@item
a protection condition, see @ref{Protection conditions},

@item
an expression of the form @code{(forall @var{V} @var{E} @var{L})},
where @var{V} is a list of variables in @var{E}, @var{E} is a logical
expression, and @var{L} is a list of logical atoms.

Such an expression can, for example, be used to implement PDDL's
@emph{conditional effects}.

@end itemize

@item
The operator's @var{delete-list} is a list of logical atoms of the
same form as the @var{add-list}.

@item
@var{cost-fn} (the operator's @strong{cost}) is a general Lisp expression. If
@var{cost-fn} is omitted, the cost defaults to 1.

@end itemize

Note that the components of an @code{:op} expression do @emph{not} need
to be presented in any special order -- @code{:add}, @code{:delete},
etc. are processed as @emph{keyword} (named) arguments.

@menu
* Internal Operators::
* Operators must be deterministic::
* Protection conditions::
* Operators Legacy Syntax::
@end menu

@node  Internal Operators, Operators must be deterministic, Operators, Operators

@subsection Internal Operators
@cindex internal operators
@anchor{#internal-operators}
As noted above, the head of the operator is a primitive task atom, so it
must begin with a primitive task symbol, i.e., a symbol that begins with
an exclamation point. Note that operator names which begin with
@emph{two} exclamation points have a special meaning in @sysname; operators
of this sort are known as @strong{internal operators}. Internal
operators are ones which are used for purposes internal to the planning
process and are not intended to correspond to actions performed in the
plan (e.g., to do some computation which will later be useful in
deciding what actions to perform). Other than requiring two exclamation
points at the start of the name, the syntax for internal operators is
identical to the syntax for other operators. @sysname {} handles internal
operators exactly the same way as ordinary operators during planning.
@sysname {} includes these operators in any plans that it returns at the end
of execution. It may, however, omit them from the printout of the final
plan (depending on the value of the @code{:verbose} argument
(@pxref{#verbose, verbose, verbose}).

The primary reason that the internal operator syntax
exists in @sysname {} is so that automated systems which use @sysname {} plans as an
input can easily distinguish between those operators which involve
action and those which were merely internal to the planning process.

@node Operators must be deterministic, Protection conditions, Internal Operators, Operators
@subsection Operators must be deterministic
@cindex Operators, deterministic

When designing an operator, it is important to ensure that each
variable symbol in the @code{add} list, @code{delete} list, and
@code{cost} always be bound to a single value when the operator is
invoked. Variable symbols can be bound in the @emph{head} of the
operator (by the method that invokes the associated primitive task) or
in the @emph{precondition} of the operator. An operator should be
written such that for any variable appearing after the precondition
(a) no two unifiers of the precondition have different bindings for
that variable, and (b) unification results in @emph{some} binding for
it, i.e. it does not remain unbound.  @sysname {} does not check this
requirement; if conflicting unifiers are available when applying an
operator, it will apply one arbitrarily. This can lead to
unpredictable behavior and plans with ambiguous semantics. In general,
we recommend that operator preconditions be designed such that only
one unifier is possible.  However, @sysname {} will be able to
correctly process operators that have multiple unifiers for
preconditions as long as no two unifiers can provide different values
for a variable that appears in the @code{add} list, @code{delete}
list, or @code{cost}.

@node Protection conditions, Operators Legacy Syntax, Operators must be deterministic, Operators
@subsection Protection conditions
@cindex protections

In the definition of operators, a @strong{protection condition} is an
expression of the form

@lisp
(:protection a)
@end lisp

@noindent
where @emph{a} is a logical atom. The purpose of a protection condition
in the add list is to tell @sysname {} that it should not execute any operator
that deletes @emph{a}. The purpose of a protection condition in the
delete list is to cancel a previously added protection condition. For
example, if we drive a delivery truck to a certain location in order to
pick up a package, then we might not want to allow the truck to be moved
away from that location until after we have picked up the package.@  To
represent this, we might use the following operators:

@lisp
(:op (!drive-to ?truck ?old-loc ?location)
   :delete ((at ?truck ?old-loc))
   :add ((at ?truck ?location)
           (:protection (at ?truck ?location))))
(:op (!pick-up ?truck ?package ?location)
  :delete
    ((at ?package ?location)
     (:protection (at ?truck ?location)))
   :add ((in ?package ?truck)))
@end lisp


@node Operators Legacy Syntax,  , Protection conditions, Operators
@subsection Operators: Legacy Syntax

In our work with @shoptwo{}, we found that operator definitions in its
original syntax were prone to
hard-to-detect syntax errors and typos that can give rise to difficult to identify
“garbage in/garbage out” bugs. Particularly prevalent are
hard-to-identify bugs arising when a programmer inadvertently reverses
the order of add and delete lists in a @sysname {} operator. These problems
are exacerbated by the extreme permissiveness of @sysname's parser.
This led us to the new syntax, described above, which relies on keywords
to make operator definitions more readable, and less error-prone.  Our
new syntax also
supports arbitrary order and the omission of empty components, without
the ``DWIM'' parsing in @shoptwo{}.
Because of its many advantages, so we encourage you to adopt the new
syntax,
instead of continuing to use the “classical” form described here,
although it is still supported.

The original operator definition syntax was as follows:

@lisp
(:operator @emph{head precondition delete-list add-list} @emph{[c]})
@end lisp

The two operators described above are written in the old syntax as
follows:

@lisp
(:operator (!drive-to ?truck ?old-loc ?location)
   ()
   ((at ?truck ?old-loc))
   ((at ?truck ?location)
    (:protection (at ?truck ?location))))
(:operator (!pick-up ?truck ?package ?location)
  ()
  ((at ?package ?location)
   (:protection (at ?truck ?location)))
  ((in ?package ?truck)))
@end lisp

For backwards compatibility with SHOP 1.x, @sysname {} will also accept
operators where the precondition @emph{P} is missing. In this case the
domain definition pre-processing code puts a null precondition into the
operator, which is always satisfied. @emph{@sysname's ability to recognize
operators without preconditions is deprecated and is likely to disappear
in the future.}



@node  Methods, Planning Domain, Operators, The SHOP3 Formalism
@section  Methods
@anchor{#methods}
A @strong{method} is a list of the form

@lisp
(:method [@var{nm}] @var{T} [@var{n@sub{1}}] @var{C@sub{1}} @var{T@sub{1}} [@var{n@sub{2}}] @var{C@sub{2}} @var{T@sub{2}} @dots{} [@var{n@sub{k}}] @var{C@sub{k}} @var{T@sub{k}})
@end lisp

@noindent
where

@itemize
@item
@var{nm} is an optional @emph{name} for this method.  Note that
@var{nm} is distinct from the (also optional) names @var{n@sub{i}} for
each (precondition, task network) pair described below.  The exception
to this rule is that if an @var{n@sub{1}} is supplied for a method
expression with only one (precondition, task network) pair,
@var{n@sub{1}} will be used as the identifier for the entire method
expression.

@item
@var{T}, also referred to as the method's @strong{head}, is a
@emph{task} atom in which no @emph{call} or @emph{eval} terms can
appear.

@item
Each @var{C@sub{i}}, a @strong{precondition} for the method, is a
logical precondition; see @ref{Logical Precondition}.

@item
Each @var{T@sub{i}}, called a @strong{tail} of the method, is a task
list. The task atoms in the list can contain @emph{call} terms.

@item
Each @var{n@sub{i}} is the @emph{name} for the succeeding
@var{C@sub{i} T@sub{i}} pair. These names are optional and if omitted a
unique name will be assigned for each pair. The names have no semantic
meaning to @sysname, but are provided in order to help the user debug
domain descriptions by looking at traces of @sysname's behavior.

@end itemize

A method indicates that the task specified in its head can be
performed by performing all of the tasks in one of its tails, when
that tail's precondition is satisfied. The preconditions in a method
are considered in the order given, and a later precondition is
considered @emph{only} if all of the earlier ones are not satisfied.

On the other hand, if there are @emph{multiple} top-level methods for a
given task available at some point in time, @emph{all} of these methods will be
considered (through backtracking). Consequently, the following code:

@lisp
(:method (eat ?food)
    (have-fork ?fork)
    ((!eat-with-fork ?food ?fork))
    (have-spoon ?spoon)
    ((!eat-with-spoon ?food ?spoon))
@end lisp

@noindent
is semantically equivalent to the following code with multiple methods
and explicitly exclusive preconditions:

@lisp
(:method (eat ?food)
   (have-fork ?fork)
   ((!eat-with-fork ?food ?fork)))

(:method (eat ?food)
    (and (not (have-fork ?fork)) (have-spoon ?spoon))
    ((!eat-with-spoon ?food ?spoon))
@end lisp

@noindent
In both of the above examples, the @code{!eat-with-spoon} operator may be
performed only if @code{(have-spoon ?spoon)} is satisfied @emph{and}
@code{(have-fork ?fork)} is not satisfied.

This should be compared with the following case, where one is permitted
to eat with @emph{either} fork or spoon -- where the spoon is not
limited to use when a fork is not available:

@lisp
(:method (eat ?food)
   (have-fork ?fork)
   ((!eat-with-fork ?food ?fork)))

(:method (eat ?food)
    (have-spoon ?spoon)
    ((!eat-with-spoon ?food ?spoon))
@end lisp

@noindent
In this case, both alternatives will be tried.

@node  Planning Domain, Planning Problem, Methods, The SHOP3 Formalism
@section  Planning Domain
@cindex domain

@anchor{#planning-domain} A @strong{planning domain} is an object that
contains all of the information for solving a class of planning
problems@footnote{The term “class” here is meant @emph{informally;}
the reader should draw no conclusions about programming language
classes in the @sysname{} implementation. -- @emph{rpg}}. At a minimum, it
will include definitions of the operators (or actions) and methods
available in the domain. A planning domain definition may also contain
axioms, or other items that are accepted by specific SHOP domain
extensions. Finally, a domain definition can @emph{include} other
domains by reference, @pxref{Inclusion directives}.
@menu
* Simple Form::
* Extended form::
* The domain variable::
* Inclusion directives::
@end menu

@node Simple Form, Extended form, Planning Domain, Planning Domain
@subsection Simple Form
@findex defdomain
@anchor{#simple-form}
A planning domain definition in the simple form looks like this:

@lisp
(defdomain @emph{domain-name} (@emph{i@sub{1}} @emph{i@sub{2}} @dots{} @emph{i@sub{n}}))
@end lisp

@noindent
where @emph{domain-name} is a symbol (which does not need to be quoted).
Beginning users of @sysname{} should simply use the simple domain-name form of
this argument.

Each item @emph{i@sub{i}} is one of the following: an operator, a
method, or an axiom.

@node Extended form, The domain variable, Simple Form, Planning Domain
@subsection Extended form
@anchor{#extended-form}
@findex defdomain
@cindex defdomain, extended form
The extended form of the @sysname {} domain definition looks like this:

@lisp
(defdomain (@var{domain-name} &rest @var{args}) (@var{i@sub{1}} @var{i@sub{2}} @dots{} @var{i@sub{n}}))
@end lisp

@noindent
@emph{args} includes the following keyword arguments:

@itemize
@item
a @code{:type} keyword argument, allowing the domain modeler to indicate a
specific subclass of the @sysname {} domain class. E.g., one might have
@code{(my-domain :type pddl-domain)}.
@cindex domain :type argument

@item
A @code{:redefine-ok} argument. If this is @code{NIL} (the default), defdomain will
warn when the domain @emph{domain-name} is already defined.
@cindex domain :redefine-ok argument

@item
A @code{:noset} argument. Should the dynamic variable @code{*domain*} be
bound as a side-effect of evaluating the @code{defdomain} expression?Currently this defaults to @code{NIL}, to provide for
backward compatibility, but I would like to see this move to defaulting
to @code{T}.  See discussion of @code{*domain*} below.
@cindex domain :noset argument

@end itemize

@node The domain variable, Inclusion directives, Extended form, Planning Domain
@subsection The @code{*domain*} variable
@vindex *domain*

This is actually a bit of a kludge. The existing @code{defdomain} implementation, as a
side-effect, sets the global variable @var{*domain*}. If this were only a
default domain name, that would be fine, but it is used everywhere as a
special variable to mean “the domain within which we are planning.” So
if there's concurrent action, or there are multiple copies of SHOP (or
its component libraries) running in a single Lisp image, bad things can
happen. I would like to stamp out the use of @var{*domain*} as a default
domain.

The question of which additional arguments are accepted in @emph{args}
is a matter for the implementer of the specialized domain type@footnote{Which must be a subclass of the @code{shop:domain} Common Lisp class.} being
used. Any additional arguments will be passed to the @code{make-instance}
method for the @code{domain} subclass.@footnote{If you don't know what this means,
you may safely ignore it.} @sysname {} extenders can create new subclasses of
domain that accept initialization arguments. A first example of the use
of this is the built-in @code{pddl-domain} class.
@tindex pddl-domain

If you are using the extended form of @code{defdomain}, you should have in hand
a new @sysname {} domain subclass, with a description of its arguments. If you
do not, you should ignore the extended form.

@node Inclusion directives,  , The domain variable, Planning Domain
@subsection Inclusion directives
@cindex :include
@cindex include directives
@cindex domain inclusion

A domain definition can include the items of another domain by reference
using the include directive:

@lisp
(:include @emph{domain-name file-name})
@end lisp

@noindent
for example

@lisp
(:include flight-operators
  #.(asdf:system-relative-pathname "core-domains" "domains.lisp"))
@end lisp

@noindent
would take the text of the flight-operators domain, which should be
found in the domains.lisp file. Note the use of the reader evaluation
form -- @code{#.} -- to force evaluation of the expression that yields the
pathname.

@b{Designer's Note:} @sysname{}'s inclusion directive is a mess.  @sysname{}
really @emph{needs} an inclusion directive, but it is a poor fit to
@code{defdomain}, because the latter is an @emph{executable macro}, but
the inclusion directive is inherently @emph{file-based}, rather than
@emph{code} (s-expression)-based. I have not been able to come up with a
more graceful solution, however. @i{--rpg}

@node  Planning Problem, Planning Problem Set, Planning Domain, The SHOP3 Formalism
@section  Planning Problem

@findex defproblem
@cindex planning problem
@vindex *problem*

A @strong{planning problem} has the form

@lisp
(defproblem @var{problem-name} @var{domain-name} (@var{a@sub{1}} @var{a@sub{2}} @dots{} @var{a@sub{n}}) @var{T})
@end lisp
@noindent
where @var{problem-name} is a symbol, @var{domain-name} is a symbol,
each @var{a@sub{i}} is a ground logical atom, and @var{T} is a task
list. This form defines a problem which may be solved by addressing the
tasks in @var{T}, using the operators, methods and axioms in
@var{domain-name}, starting in an initial state defined by the ground atoms
@var{a@sub{1}} through @var{a@sub{n}}.

@include include/macro-shop-defproblem.texinfo

The corresponding functional interface is:

@include include/fun-shop-make-problem.texinfo

@node  Planning Problem Set, Plans, Planning Problem, The SHOP3 Formalism
@section  Planning Problem Set
@findex def-problem-set

A @strong{planning problem set} has the form

@lisp
(def-problem-set @var{set-name} (@var{p@sub{1}} @var{p@sub{2}} @dots{} @var{p@sub{n}}))
@end lisp

@noindent
where @var{set-name} is a symbol and each @var{p@sub{i}} is the name
of a planning problem.

@node  Plans, Simple example, Planning Problem Set, The SHOP3 Formalism
@section  Plans
@cindex plans

The previous subsections describe the inputs to @sysname. This subsection
describes the result that @sysname{} produces. A @strong{plan} is a list of
the form

@emph{(h@sub{1} c@sub{1} h@sub{2} c@sub{2} @dots{} h@sub{n} c@sub{n} )}

@noindent
where each @emph{h@sub{i}} and @emph{c@sub{i}}, respectively, are the
head and the cost of a ground operator instance @emph{o@sub{i}}. If
@emph{p} = (@emph{h@sub{1}} @emph{c@sub{1} h@sub{2}} @emph{c@sub{2}} @dots{}
@emph{h@sub{n} c@sub{n}}) is a plan and @emph{S} is a state, then
@emph{p}(@emph{S}) is the state produced by starting with @emph{S} and
executing @emph{o@sub{1}}, @emph{o@sub{2}}, @dots{}, @emph{o@sub{n}} in the
order given. The @strong{cost} of the plan @emph{p} is @emph{c@sub{1 }}+
@emph{c@sub{2 }}+ @dots{} + @emph{c@sub{n}} (thus, the cost of the empty
plan is 0).

Often what is wanted is a truncated version of the plan sequence, with
the @emph{internal operators}
(@pxref{#internal-operators,internal operators,internal operators})
and costs removed.  For this, one may use

@include include/fun-shop-shorter-plan.texinfo

@node  Simple example,  , Plans, The SHOP3 Formalism
@section Simple example
@cindex example

This very simple, ready-to-run example illustrates the basics of what
we've covered so far about @sysname.

@lisp
(in-package :shop-user)

(defdomain simple
    (
     (:op (!pickup ?a)
      :add ((have ?a)))

     (:op (!drop ?a)
      :precond (and (have ?a))
      :delete ((have ?a)))

     (:method (swap ?x ?y)
       dec0
       (and (have ?x) (have ?y))
       () ; nothing to do
       dec1
       ((have ?x))
       ((!drop ?x) (!pickup ?y))
       dec2
       ((have ?y))
       ((!drop ?y) (!pickup ?x)))
     )
  )

(defproblem p1 simple
  ((have banjo))       ; facts
  ((swap banjo kiwi))  ; task list
  )

(find-plans 'p1 :verbose :plans)

@end lisp



@node PDDL Support, The SHOP Theorem Prover, The SHOP3 Formalism, Top
@chapter PDDL Support
@anchor{#pddl-compatibility}
The current release of @sysname {} provides a preliminary capability to
incorporate PDDL domain definitions into a @sysname {} domain. You should be
able to incorporate components of a PDDL domain definition into a @sysname{}
domain definition of @code{:type pddl-domain} or @code{simple-pddl-domain}. A
@code{pddl-domain} corresponds to a PDDL domain of the ADL type. The
@code{pddl-domain }uses conditional-effects, existential-preconditions,
universal-preconditions, and equality (note that these are @emph{PDDL}
conditional effects, existential preconditions and universal
preconditions; these are @emph{not} SHOP-syntax conditional effects,
etc.). A @code{simple-pddl-domain} will not have conditional-effects,
existential-preconditions, universal-preconditions, or equality.

Currently the PDDL integration is a little bumpy, and details are in
flux.

PDDL action names are translated into names that SHOP will recognize as
primitives (e.g., @t{move} would become @t{!move}, and would have to be
referenced that way in SHOP method definitions that use it).

You must splice the PDDL domain components into the SHOP domain
definition. Typically, the best way to do this is to use an @t{:include}
form (@pxref{Inclusion directives} ).

Fully ground STRIPS-style domains -- i.e., those where a set of STRIPS
operators has been exploded into a large set of ground operators by some
automated transformation -- will work very poorly.

Note that the parsing of PDDL domains in SHOP is not strict. This is
intentional, because we don't want to make it impossible to include SHOP
constructs together with PDDL constructs. However, there should probably
be a “strict mode” that checks for true conformance with PDDL syntax.
@menu
* PDDL Metric Fluents::
* PDDL Methods::
* PDDL Domain Classes::
@end menu

@node  PDDL Metric Fluents, PDDL Methods, PDDL Support, PDDL Support
@section PDDL Metric Fluents

We have recently added support for PDDL operators with metric fluents,
signaled by PDDL's @t{:fluents} requirement.
Metric fluents are numerically-valued functions of domain objects.  Here
is an example taken from Fox and Long's paper on PDDL 2.1, and updated
to the changes in PDDL syntax they specify:

@example
(define (domain jug-pouring)
  (:requirements :typing :fluents)
  (:types jug)
  (:functions
   (amount ?j - jug) (capacity ?j - jug))
  (:action empty
    :parameters (?jug1 ?jug2 - jug)
    :precondition (>= (- (capacity ?jug2) (amount ?jug2))
                                 (amount ?jug1)))
    :effect (and (assign (amount ?jug1) 0)
                       (assign (amount ?jug2)
                              (+ (amount ?jug1) (amount ?jug2))))))
@end example

In the above example, the two functions are @t{amount} and @t{capacity},
and we see use of the update operator @t{assign} (other such operators
are @t{increase}, @t{decrease}, @t{scale-up}, and @t{scale-down}), the
comparison predicate @code{>=} (there are also @code{<=}, @code{<},
@code{>}, and @code{=}),
and the binary arithmetic operators
@code{-} and @code{+} (@code{*} and @code{/} are also supported).

@tindex FLUENTS-MIXIN
@xref{PDDL Domain Classes}, specifically the discussion of the
@code{fluents-mixin} class for more details.

@subsection Implementation Notes

As the name suggests, the @code{domain} mixin class @code{fluents-mixin}
is responsible for the correct interpretation of PDDL metric fluents.
This requires extensions to the SHOP theorem prover and to the
interpretation of PDDL actions.

@cindex FLUENT-VALUE
In its state representation, SHOP stores the current values of metric
fluents using the dedicated predicate @code{FLUENT-VALUE}, as in, for
example: @code{(fluent-value (capacity jug0) 12)}.   When the value of a
metric fluent must be found, this is the form of literal that is
actually retrieved.

@cindex F-EXP-VALUE
In the grammar of PDDL, there are also fluent expressions (@t{f-exp}s)
that are made up of fluent values, numbers, binary and unary operators.
Internally, the SHOP theorem-prover uses the special predicate
@code{F-EXP-VALUE} to find values of such expressions, and has a
special-purpose inference rule coded for them.  These expressions appear
both in preconditions (as part of comparison predications) and in action
effects (as part of updates).

@cindex FLUENT-CHECK
A fluent comparison (@code{f-comp} in the PDDL grammar) is a binary
comparison applied to two @code{f-exp}s.  Internally, the theorem-prover
uses the distinguished predicate @code{fluent-check} to check these.  As
one would expect, it first evaluates the two fluent expressions and then
applies the comparison operator.

When handling updates to fluent expressions, parsing methods on the
@code{fluents-mixin} class will translate update expressions into new
@code{fluent-update} expressions of the following form:

@example
(fluent-update @var{update-op} @var{fluent-function} @var{f-exp})
@end example

@findex APPLY-ACTION
Special code for handling such effect expressions has been added to the
@code{apply-action} function in SHOP.

@node PDDL Methods, PDDL Domain Classes, PDDL Metric Fluents, PDDL Support
@section PDDL Methods
@anchor{#pddl-methods}
In order to support replanning, we have developed “PDDL methods” that
have more limited expressive power than normal @sysname {} methods, and that
have clearer semantics. This feature is @emph{experimental:} the syntax,
semantics, and implementation are all likely to change.

PDDL method proposed syntax:

@lisp
(:pddl-method @emph{head@sub{[φ]} precond@sub{[φ]} body@sub{[φ]}})
@end lisp


As in normal @sysname {} methods (see Section 4.11), a PDDL Method's head is a
task. We notate it here as @emph{head@sub{[φ]}} in order to indicate
that some set of variables, φ, may appear free in the head. Similarly,
we have @emph{precond@sub{[φ]}} and @emph{body@sub{[φ] }}to indicate
that φ may appear free in the preconditions and the body. A PDDL
method's preconditions must be an enhanced PDDL goal expression (see
below). A PDDL method's body must be an ordered task network. In the
interests of clean syntax, task network keywords (:ordered and
:unordered) are @emph{not} optional, and must be provided. For the
moment, only ordered task networks are supported; unordered task
networks may be supported later.

Note that provision for free variables does not relax the constraint
that all operators must be ground when inserted into the plan. The
intention is to allow the variables in φ to be bound by the
preconditions. As in PDDL operators, only the variables in the head of a
PDDL method are scoped over the preconditions and the body (in standard
@sysname {} methods we have Prolog-style scoping where any free variable is
implicitly scoped over the entire method).

Note also that PDDL methods do @emph{not} permit multiple precondition
sets and task networks in a single PDDL method form, and so do
@emph{not} support the if-then-else semantics of @sysname {} method forms. To
get this kind of semantics in PDDL methods, the programmer must supply a
set of methods with mutually-exclusive and exhaustive preconditions.

PDDL methods may only be used in domains that are a subclass of
@code{SIMPLE-PDDL-DOMAIN} (@pxref{PDDL Domain Classes}).
@menu
* Enhanced Preconditions::
@end menu

@node Enhanced Preconditions,  , PDDL Methods, PDDL Methods
@subsection Enhanced Preconditions
@cindex PDDL method preconditions
@cindex Sorting in PDDL method preconditions
PDDL method preconditions are based on PDDL @emph{goals}, but with the
following extensions:

@itemize
@item
A PDDL method's preconditions may use the @code{:sort-by} keyword. More precisely:
@example
@multitable {precond} {@math{P} | @math{P_v} with @math{v} a method parameter}
@item @math{P} @tab ::= PDDL goal
@item @math{v} @tab ::= PDDL/SHOP variable
@item @math{P_v} @tab ::= PDDL goal with @math{v} appearing free
@item precond @tab ::= @math{P} | @math{P_v} with @math{v} a method parameter
   | @code{:sort-by} @math{v} [<rel>] @math{P_v}
@end multitable
@end example

@item
Variables that appear free in the head of the PDDL
method may appear free in the precondition, hence the use of @math{P}
and @math{P_v}.

@end itemize

PDDL goals are as described in the PDDL syntax (we have used the PDDL
2.1 paper as primary source). Note that PDDL goals with free variables
are permitted, as long as the free variables appear in the parameters
for the task.

Currently we do not support typing in PDDL method task heads, but this
could change.

@node PDDL Domain Classes,  , PDDL Methods, PDDL Support
@section PDDL Domain Classes

In order to implement the requirements of PDDL, @sysname {} contains a number
of classes, which can be used when defining domains with @code{defdomain}
(@pxref{Planning Domain}).

@itemize
@item
@tindex SIMPLE-PDDL-DOMAIN
@code{SIMPLE-PDDL-DOMAIN} -- this is the base class. All PDDL domain classes
should include this class.

@item
@tindex PDDL-DOMAIN
@code{PDDL-DOMAIN} -- for historical reasons, this class corresponds roughly to
PDDL domains with the ADL requirements. Use of this class is
@emph{deprecated;} it was added without sufficient thought.

@item
@tindex ADL-DOMAIN
@code{ADL-DOMAIN} -- @code{SIMPLE-PDDL-DOMAIN} with @code{ADL-MIXIN} (see below).

@item
Mixin classes for different requirements:

@itemize
@item
@tindex NEGATIVE-PRECONDITIONS-MIXIN
@code{NEGATIVE-PRECONDITIONS-MIXIN}

@item
@tindex DISJUNCTIVE-PRECONDITIONS-MIXIN
@code{DISJUNCTIVE-PRECONDITIONS-MIXIN}

@item
@tindex UNIVERSAL-PRECONDITIONS-MIXIN
@code{UNIVERSAL-PRECONDITIONS-MIXIN}

@item
@tindex EXISTENTIAL-PRECONDITIONS-MIXIN
@code{EXISTENTIAL-PRECONDITIONS-MIXIN}

@item
@tindex QUANTIFIED-PRECONDITIONS-MIXIN
@code{QUANTIFIED-PRECONDITIONS-MIXIN} -- this simply inherits universal and
existential preconditions, since they are typically used together.

@item
@tindex CONDITIONAL-EFFECTS-MIXIN
@code{CONDITIONAL-EFFECTS-MIXIN}

@item
@tindex EQUALITY-MIXIN
@code{EQUALITY-MIXIN}

@item
@tindex PDDL-TYPING-MIXIN
@code{PDDL-TYPING-MIXIN}

@item
@tindex COSTS-MIXIN
@code{COSTS-MIXIN}

@item
@tindex ADL-MIXIN
@code{ADL-MIXIN}

@item
@tindex FLUENTS-MIXIN
@code{FLUENTS-MIXIN}

@end itemize

@end itemize

@node The SHOP Theorem Prover, The SHOP Unifier, PDDL Support, Top
@chapter The SHOP Theorem Prover
@anchor{#using-the-shop-theorem-prover}
One of the main extensions that SIFT has made to @sysname {} is to make its
theorem prover usable separately. The @sysname {} theorem-prover is very
similar to Prolog, but operates over a state that changes over time.
Note, however, that the prover does not (at least not yet) support
temporal modalities such as ``previously,'' ``next,'' or ``always.''

The theorem-prover is supplied only as a toolbox unlike the unifier
(@pxref{The SHOP Unifier}), which provides functionality that is ready to
use ``out-of-the box.''  Specifically, it does not contain any built-in
functionality for advancing the world state; this needs to be developed
by the programmer, based on facilities supplied by @sysname{}'s
``common'' subsystem.
The theorem-prover relies critically on the unifier subsystem, and
re-exports most of the key functions from the unifier package.

The top-level function of the theorem-prover is @emph{query}, which is
built on top of the more difficult-to-use @emph{find-satisfiers}:

@include include/fun-shopthpr-query.texinfo
@include include/fun-shopthpr-find-satisfiers.texinfo


The theorem prover has its own notion of a @emph{domain} object, but
unlike the full @sysname{} domain, this one supports only specification
of axioms (although it can be extended by the programmer).

@include include/class-shopthpr-thpr-domain.texinfo


@node The SHOP Unifier, Plan Grapher, The SHOP Theorem Prover, Top
@chapter The SHOP Unifier

The @sysname{} unifier may be loaded stand-alone with
@example
(asdf:load-system "shop3/unifier")
@end example

It provides a library that may be useful for general symbolic
computation that requires unification of first order (or, indeed, higher
order) logical expressions represented as Lisp s-expressions.

@include include/fun-shopunif-unify.texinfo

The @code{unify} function is also exported from the @sysname{}
theorem-prover package and the top level @sysname{} package.

To check the results of unification, @sysname{} offers these predicates:

@include include/macro-shopunif-unify-p.texinfo
@include include/macro-shopunif-unify-fail.texinfo
@include include/macro-shopunif-unify-fail-p.texinfo

A @emph{binding-list} or @emph{substitution} is a list of
@emph{bindings}:

@include include/struct-shopunif-binding.texinfo

Accessors:

@include include/fun-shopunif-binding-val.texinfo
@include include/fun-shopunif-binding-var.texinfo

Utility functions:

@include include/fun-shopunif-make-binding-list.texinfo
@include include/fun-shopunif-binding-list-value.texinfo

To apply a unifier in a target expression, use
@code{apply-substitution}:

@include include/macro-shopunif-apply-substitution.texinfo

The following are some predicates that may be useful to a programmer using
the unifier at a low level.

@include include/macro-shopunif-variable-p.texinfo

@include include/fun-shopunif-variablep.texinfo

@include include/fun-shopunif-anonymous-var-p.texinfo

@include include/fun-shopunif-groundp.texinfo


Finally, before unifying, it may be necessary to @emph{standardize} the
expressions -- renaming variables to be unique.

@include include/fun-shopunif-standardize.texinfo

@node Plan Grapher, Data Structures, The SHOP Unifier, Top
@chapter Plan Grapher

In order to make the plan trees that @sysname{} can produce more useful,
we have developed the @sysname{} plan grapher.

@include include/fun-spg-graph-plan-tree.texinfo
@include include/fun-spg-graph-enhanced-plan-tree.texinfo

@include include/class-spg-enhanced-plan-tree-graph.texinfo
@include include/class-spg-plan-tree-graph.texinfo

@node Data Structures, General Notes on SHOP3, Plan Grapher, Top
@chapter Data Structures

@menu
* States::
@end menu

@node States,  , Data Structures, Data Structures
@section States

A state represents the state of the world at any given time, and is
identified with a set of ground literals.@footnote{Note that the state
of the world is @emph{not} the same as the search state.  The
(projected) world state is only one component of the search state.}
The meaning of the state is a function of this set of ground literals
and the set of axioms in effect. For more discussion of the semantics
of states, see @pxref{States and Satisfiers}.

The programmer may choose from a number of different representations of
world states, which may be more or less efficient, depending on the
problem at hand:

@itemize
@item @code{:list} --
This is the simplest state representation, a
simple list of facts. As the set of facts in the state description
grows, the linear search for lookup that is required here will become
increasingly expensive.
@item @code{:hash} --
In this representation, the state is represented as a hash table of
propositions.  The performance of this alternative will depend on how
well the host implementation hashes full s-expressions.
@item @code{:mixed} --
This encoding, which is the default, uses a hash table, but hashes each
state literal on its predicate.  As long as there are not very large
data tables in the state, this should be quite efficient.  If there are
many facts with the same predicate, this will devolve to linear search.
@item @code{:doubly-hashed} --
@b{Newly added.}
Similar to the @code{:mixed} representation, the state is represented as
a hash table, indexed on state predicates.  However, each hash bucket in
this representation is itself a hash table, indexed on the value of the
first argument.  This should often improve performance on large data
tables, where there are often checks of single facts.
@item @code{:bit} --
The state is encoded as vectors, based on argument indices, etc. I don't
understand the implementation well, nor do I understand under what
conditions it will work well or badly. I believe for this to be correct,
the set of possible values for a given predicate's arguments must be
known in advance, but I can't say for sure. It would be helpful for
someone to dig into this more deeply.  Until someone does, @emph{this
representation is probably to be avoided.}
@end itemize

Adding a new state representation is a relatively easy thing to do.  Any
new state data structure must be a structure that extends
@code{shop3.common::tagged-state}.  It must support the following
generic functions:

@include include/fun-shop3cmn-make-initial-state.texinfo

@include include/fun-shop3cmn-state-gt-state-type.texinfo

@include include/fun-shop3cmn-insert-atom.texinfo

@include include/fun-shop3cmn-remove-atom.texinfo

@include include/fun-shop3cmn-state-atoms.texinfo

@include include/fun-shop3cmn-atom-in-state-p.texinfo

@code{state-all-atoms-for-predicate} @c This should be in the auto-generated document files,
@c but isn't.

@code{state-candidate-atoms-for-goal} @c This should be in the auto-generated document files,
@c but isn't.

@include include/fun-shop3cmn-copy-state.texinfo


@node General Notes on SHOP3, Internal Technical Information, Data Structures, Top
@chapter General Notes on @sysname {}

@menu
* More on axioms::
@end menu

@node More on axioms,  , General Notes on SHOP3, General Notes on SHOP3
@section More on axioms
@anchor{#more-on-axioms}

@enumerate

@item
@strong{Prolog.}
@sysname's axiom syntax and semantics are like those of Prolog's Horn
clauses.
@itemize
@item
@code{(:- (p ?x) (q ?x))} is patterned after Prolog's @code{p(x) :- q(x)}.
@item
As in Prolog, there is implicit universal quantification over
@emph{all} variables.  For example the axiom
@lisp
(:- (p ?x ?y) (q ?x ?z))
@end lisp
@noindent
means @math{\forall x\,\forall y\,\forall z\; \bigl( q(x,z)
\rightarrow p(x,y) \bigr)}.
@end itemize

@item
@strong{Lisp in axioms.}
An axiom may invoke arbitrary Lisp functions, but only through the
@code{eval}, @code{call}, and @code{assign} family of
pseudo-predicates.  Note that these functions do not have access to
the current state, except by using the special variable
@code{shop::*current-state*}.
@vindex *current-state*

Other predicates are addressed through the theorem-prover. The theorem
prover knows about @sysname{}'s state and queries will be evaluated in
the context of the current state.

By default, the theorem prover will search for all solutions to a
query (you can use the @code{:just-one} flag to avoid this), and
recursive queries will cause the theorem-prover to go away forever.

@item
@strong{Axioms vs. facts.}
Since the null conjunct is always true, an axiom of the form @code{(:-
a nil)} is equivalent to asserting the atom @var{a} as a basic
fact. The difference is that the expression @code{(:- a nil)} is what
one would put into the set of axioms for the problem domain, whereas
the atom @var{a} is what one would put into a state description. Such
an atom can be deleted by an operator, but with the axiom @code{(:- a
nil)}, @var{a} is always true and no operator can change that.

@item
@strong{Multiple tails vs. separate axioms.}
An axiom with several conjuncts in its tail has different semantics
than what you would get by making each conjunct the tail of a separate
axiom. Consider the following axiom lists:

@lisp
X1 = ((:- (a ?x) ((b ?x)) ((c ?x))))
X2 = ((:- (a ?x) ((b ?x))) (:- (a ?x) ((c ?x))))
@end lisp
@noindent

In @var{X1}, the single axiom acts like an if-then-else:
if @code{((b ?x))} is true then @code{find-satisfiers} returns the
satisfiers for @code{(b ?x)}; otherwise if @code{((c ?x))} is true
then it returns the satisfiers for @code{(c ?x)}.  For example,
@lisp
(find-satisfiers '((a ?u)) '((b 2) (c 3)))
@end lisp
@noindent
would return @code{(((?u . 2)))}.

On the other hand, in @var{X2} the set of axioms acts like a
logical ``or'': @code{find-satisfiers} returns every satisfier for
@code{(b ?x)} @emph{and} every satisfier for @code{(c ?x)}. In this case,
@lisp
(find-satisfiers '((a ?u)) '((b 2) (c 3)))
@end lisp
@noindent
would return @code{(((?u . 2)) ((?u . 3)))}.


@end enumerate


@section Tasks, methods, operators, plans

@enumerate
@item
Since a primitive task name is basically a call to an operator, you
should never create a set of methods and operators that has more than
one operator for the same primitive task. Otherwise your plans will be
ambiguous.

@item
In the following two calls to @code{find-plans} @sysname {} will find the same set of
all shallowest plans, but in the first case @sysname {} will use a depth-first
search and in the second case it will use an iterative-deepening search:

@lisp
(find-plans 'p :which :all-shallowest)
(find-plans 'p :which :id-all)
@end lisp
@noindent
Likewise, the following two calls to @sysname {} will both find the same
shallowest plan, but in the first case @sysname {} will use a depth-first
search and in the second case it will use an iterative-deepening search:
@lisp
(find-plans 'p :which :shallowest)
(find-plans 'p :which :id-first)
@end lisp

@end enumerate


@node Internal Technical Information, Acknowledgments, General Notes on SHOP3, Top
@chapter Internal Technical Information

@strong{This section has not been updated since the transition
from @shoptwo {} to @sysname {}, and its accuracy is likely
compromised.} @i{Caveat lector.}

This section presents information about the internal workings of the
@sysname {} planning process. @strong{Important Note}: This section is
primarily of interest to planning researchers and planning system
developers. Most @sysname {} users (especially beginning users) are advised to
skip this section.

The first subsection presents some key internal knowledge structures
that must be defined in order to completely specify the behavior of
@sysname. The second subsection presents the formal semantics of operators
and plans. The third subsection describes an assortment of functions
within @sysname {} that are used to accomplish those semantics.
@menu
* Internal Knowledge Structures::
* Formal Semantics::
* Key Functions in @sysname: Key Functions in SHOP3.
@end menu

@node Internal Knowledge Structures, Formal Semantics, Internal Technical Information, Internal Technical Information
@section Internal Knowledge Structures
@anchor{#internal-knowledge-structures}
The following @sysname {} internal knowledge structures must be defined in
order to fully specify the semantics of plan generation in @sysname.
@menu
* Substitutions::
* States and Satisfiers::
@end menu

@node Substitutions, States and Satisfiers, Internal Knowledge Structures, Internal Knowledge Structures
@subsection Substitutions
@anchor{#substitutions}

@c FIXME: Rewrite the discussion of substitutions.
@strong{Update note:} @emph{The variable bindings in a substitution are
no longer represented by dotted pairs. Instead, they are represented by
Common Lisp @strong{structures} that have `binding-var` and
`binding-value` slots. So, until there has been time for a rewrite,
please read “binding structure” for “dotted pair” in the following. [rpg
12 June 2018]}

A @strong{substitution} is a list of dotted pairs of the form

@quotation
@emph{((x@sub{1} . t@sub{1}) (x@sub{2} . t@sub{2}) @dots{} (x@sub{k} .
t@sub{k})) }
@end quotation
@noindent
where every @emph{x@sub{i}} is a variable symbol and every
@emph{t@sub{i}} is a term. If @emph{e} is an expression and @emph{u} is
the above substitution, then the @strong{substitution instance}
@emph{e@sup{u}} is the expression produced by starting with @emph{e} and
replacing each occurrence of each variable symbol @emph{x@sub{i}} with
the corresponding term @emph{t@sub{i}}.

If @emph{d} and @emph{e} are two expressions, then:

@itemize
@item
@emph{d} is a @strong{generalization} of @emph{e} if @emph{e} is a
substitution instance of @emph{d};

@item
@emph{d} is a @strong{strict generalization} of @emph{e} if @emph{d} is
a generalization of @emph{e} but @emph{e} is not a generalization of
@emph{d};

@item
@emph{d} and @emph{e} are @strong{equivalent} if each is a
generalization of the other.

@end itemize

If @emph{u} and @emph{v} are two substitutions, then:

@itemize
@item
@emph{u} is a @strong{generalization} of @emph{v} if for every
expression @emph{e}, @emph{e@sup{u}} is a generalization of
@emph{e@sup{v}};

@item
@emph{u} is a @strong{strict generalization} of @emph{v} if for every
expression @emph{e}, @emph{e@sup{u}} is a strict generalization of
@emph{e@sup{v}};

@item
@emph{u} and @emph{v} are @strong{equivalent} if for every expression
@emph{e}, @emph{e@sup{u}} and @emph{e@sup{v}} are equivalent.

@end itemize

If @emph{e} is an expression and @emph{x@sub{1}, x@sub{2}, @dots{},
x@sub{k}} are the variable symbols in @emph{e}, then a
@strong{standardizer} for @emph{e} is a substitution of the form

@quotation
@emph{((x@sub{1} . y@sub{1}) (x@sub{2} . y@sub{2}) @dots{} (x@sub{k} .
y@sub{k})) }
@end quotation
@noindent
where each @emph{y@sub{i}} is a new variable symbol that is not used
anywhere else. Note that if @emph{u} is a standardizer for @emph{e},
then @emph{e} and @emph{e@sup{u}} are equivalent expressions.

If @emph{d} and @emph{e} are expressions and there is a substitution
@emph{u} such that @emph{d@sup{u}} = @emph{e@sup{u}}, then @emph{d} and
@emph{e} are @strong{unifiable} and @emph{u} is a @strong{unifier} for
them. A unifier of @emph{d} and @emph{e} is a @strong{most general
unifier} (or @strong{mgu}) of @emph{d} and @emph{e} if it is a
generalization of every unifier of @emph{d} and @emph{e}. Note that all
mgu's for @emph{d} and @emph{e} are equivalent.

@node States and Satisfiers,  , Substitutions, Internal Knowledge Structures
@subsection States and Satisfiers
@anchor{#states-and-satisfiers}
A @strong{state} is a list of ground atoms intended to represent some
``state of the world''.  A conjunct @var{C} is a @strong{consequent} of a
state @var{S} and an axiom list @var{X} if every logical expression
@var{l} in @var{C} is a consequent of @var{S} and @var{X}. A logical
expression @var{l} is a consequent of @var{S} and @var{X} if one of
the following is true:

@itemize
@item
@var{l} is an atom in @var{S};

@item
@var{l} is a ground expression of the form @code{(eval @var{f t@sub{1} t@sub{2}
@dots{} t@sub{n}})}, and the evaluation of @var{f} with arguments
@var{t@sub{1},t@sub{2},@dots{},t@sub{n}} returns a non-nil value;

@item
@var{l} is a ground expression of the form @code{(call @var{f t@sub{1} t@sub{2}
@dots{} t@sub{n}})}, and the evaluation of @var{f} with arguments
@var{t@sub{1},t@sub{2},@dots{},t@sub{n}} returns a non-nil value;

@item
@var{l} is an expression of the form (not @var{a}), and the atom
@var{a} is not a consequent of @var{S} and @var{X};

@item
@var{l} is an expression of the form (assign @var{v} @var{t}), where
@var{v} is a variable symbol and @var{t} is any Lisp expression. The
value of @var{t}, which was evaluated via a call to the Lisp evaluator,
is a substitution of @var{v}, i.e.@var{( v . t).} This term is always
a consequent of @var{S} and @var{X};

@item
@var{l} is an expression of the form (or @var{l@sub{1} l@sub{2} @dots{}
l@sub{n}}), where @var{l@sub{1}}, @var{l@sub{2}}, @var{l@sub{3}},
@dots{}, @var{l@sub{n}} are logical expressions, and at least one
expression in this list is a consequent of @var{S} and @var{X;}

@item
@var{l} is an expression of the form @code{(forall @var{V Y Z})}, where
@var{Y} and @var{Z} are logical expressions and @var{V} is the list
of variables in @var{Y} such that for every satisfier @var{u} that
satisfies @var{Y} in @var{S} and @var{X}, @var{u} also satisfies
@var{Z} in @var{S} and @var{X};

@item
@var{l} is an expression of the form @code{(imply @var{Y Z})}, where @var{Y}
and @var{Z} are logical expressions such that any satisfier @var{u}
that satisfies @var{Y} in @var{S} and @var{X} also satisfies @var{Z} in
@var{S} and @var{X};

@item
there exists a substitution @var{v} and an axiom @code{(:- @var{a} n@sub{1}
@var{C@sub{1}} n@sub{2} @var{C@sub{2 }}@dots{} n@sub{n} @var{C@sub{n}})}
in @var{X} such that @var{l} = @var{a@sup{v}} and one of the
following holds:

@itemize
@item
@var{C@sub{1}@sup{v}} is a consequent of @var{S} and @var{X};

@item
@var{C@sub{1}@sup{v}} is not a consequent of @var{S} and @var{X}, but
@var{C@sub{2}@sup{v}} is a consequent of @var{S} and @var{X};

@item
neither @var{C@sub{1}@sup{v}} nor @var{C@sub{2}@sup{v}} is a
consequent of @var{S} and @var{X}, but @var{C@sub{3}@sup{v}} is a
consequent of @var{S} and @var{X};

@item
@dots{};

@item
none of @var{C@sub{1}@sup{v}}, @var{C@sub{2}@sup{v}},
@var{C@sub{3}@sup{v}}, @dots{}, @var{C@sub{n-1}@sup{v}} is a consequent of
@var{S} in @var{X}, but @var{C@sub{n}@sup{v}} is a consequent of
@var{S} and @var{X}.

@end itemize

@end itemize

If @var{C} is a consequent of @var{S} and @var{X}, then it is a
@strong{most general consequent} of @var{S} and @var{X} if there is no
strict generalization of @var{C} that is also a consequent of @var{S}
and @var{X}.

Let @var{S} be a state, @var{X} be an axiom list, and @var{C} be an
ordinary conjunct. If there is a substitution @var{u} such that
@var{C@sup{u}} is a consequent of @var{S} and @var{X}, then we say
that @var{S} and @var{X} @strong{satisfy} @var{C} and that @var{u}
is the @strong{satisfier}. The satisfier @var{u} is a @strong{most
general satisfier} (or @strong{mgs}) if there is no other satisfier that
is a strict generalization of @var{u}. Note that @var{C} can have
multiple non-equivalent mgs's. For example, suppose @var{X} contains
the ``walking distance'' axiom given earlier, and @var{S} is the state

@lisp
((weather-is good)
 (distance home convenience-store 1)
 (distance home supermarket 2))
@end lisp
@noindent
Then for the conjunct @code{((walking-distance ?y))}, there are two mgs's from
@var{S} and @var{X}: @code{((?y . convenience-store))} and @code{((?y .
supermarket))}.

Let @var{S} be a state, @var{X} be an axiom list, and @code{C =
(:first C')} be a tagged conjunct. If @var{S} and @var{X} satisfy
@var{C'}, then the mgs (most general satisfier) for @var{C} from
@var{S} and @var{X} is the @emph{first} mgs for @var{C'} that would be
found by a left-to-right depth-first search. For example, if @var{S}
and @var{X} are as in the previous example, then for the tagged
conjunct @code{(:first (walking-distance ?y))}, the mgs from @var{S}
and @var{X} is @code{((?y . convenience-store))}.

@node Formal Semantics, Key Functions in SHOP3, Internal Knowledge Structures, Internal Technical Information
@section Formal Semantics
@anchor{#formal-semantics}
Recall that a plan is a list of operator invocations with costs and that
an operator has an add list and a delete list. Informally, the meaning
of the plan is that the specified operators are performed in sequence,
incurring the specified costs. Similarly, the meaning of the operator is
that the assertions in the add list are added to the state and the
assertions in the delete list are removed from the state. The meaning of
a method is that when the method's precondition is satisfied, the task
specified in the method's head can be performed by performing each of
the tasks specified in the method's tail.

This subsection elaborates these informal notions, presenting detailed
formal semantics of operators and plans. It is of particular use to
anyone who has a @sysname {} domain and wishes to prove theorems (e.g.,
correctness, completeness, etc.) regarding plans generated in that
domain.
@menu
* Semantics of Operators::
* Semantics of Methods::
* Semantics of Plans::
@end menu

@node Semantics of Operators, Semantics of Methods, Formal Semantics, Formal Semantics
@subsection Semantics of Operators
@anchor{#semantics-of-operators}
@emph{@strong{Update note:} @sysname {} now supports PDDL operators, which
have cleaner (but more restricted) semantics. Their semantics is
discussed in many treatments of the PDDL specification. We hope to add
an explanation later. See Chapter} @emph{7 for discussion of PDDL
support in @sysname. [12 June 2018 -- rpg]}

The intent of an operator is to specify that the task @emph{h} can be
accomplished at a cost of @emph{c}, by modifying the current state of
the world to remove every logical atom in @emph{D} and add every logical
atom in @emph{A} if @emph{P} is satisfied in the current state. In order
to prevent plans from being ambiguous, there should be at most one
operator for each primitive task symbol. @emph{Furthermore, whenever an
action is inserted into a plan, it must be @strong{ground} -- there must
be no unbound parameters in its task head. [Inserted 12 June 2018 based
on discussions with Ugur -- rpg]}

Let @emph{S} be a state, @emph{X} be the list of axioms, @emph{L} be the
list of protected conditions, @emph{t} be a primitive task atom, and
@emph{o} be a planning operator whose head, precondition, delete list,
add list, and cost are @emph{h}, @emph{P}, @emph{D}, @emph{A}, and
@emph{c}, respectively. Suppose that there is an mgu @emph{u} for
@emph{t} and @emph{h}, such that @emph{h@sup{u}} is ground, that none of
the ground atoms in @emph{D@sup{u}} are in the list of protected
conditions, and @emph{P@sup{u}} is satisfied in S. Then we say that
@emph{o@sup{u}} is @strong{applicable} to @emph{t}, and that
@emph{h@sup{u}} is a @strong{simple plan} for @emph{t}. If @emph{S} is a
state, then the state and the protection list produced by executing
@emph{o@sup{u}} (or equivalently, @emph{h@sup{u}}) in @emph{S} and
@emph{L} is the new state:

(@emph{S'},@emph{L'}) = result(@emph{S,L,h@sup{u}}) =
result(@emph{S,L,o@sup{u}}) = (@emph{S - D@sup{u}}) U @emph{A@sup{u}.}

@noindent
where @emph{S'} and @emph{L'} are obtained by modifying the current
state of the world and the list of protected conditions as follows:

@itemize
@item
remove every logical atom in @emph{D@sup{u}} from the current state;

@item
remove every protection condition in @emph{D@sup{u}} from the list of
protected conditions;

@item
for every expression (forall V Y Z) in @emph{D@sup{u}} and every
satisfier @emph{v} such that @emph{S} and @emph{X} satisfy
@emph{Y@sup{v}}, remove every logical atom in @emph{Z@sup{u}} from the
current state;

@item
for every expression (forall V Y Z) in @emph{D@sup{u}} and every
satisfier @emph{v} such that @emph{S} and @emph{X} satisfy
@emph{Y@sup{v}},, remove every protection condition in @emph{Z@sup{u}}
from the list of protected conditions;

@item
add every logical atom in @emph{A@sup{u}} to the current state;

@item
add every protection condition in @emph{A@sup{u}} to the list of
protected conditions;

@item
for every expression (forall V Y Z) in @emph{A@sup{u}} and every
satisfier @emph{v} such that @emph{S} and @emph{X} satisfy
@emph{Y@sup{v}}, add every logical atom in @emph{Z@sup{u}} to the
current state;

@item
for every expression (forall V Y Z) in @emph{A@sup{u}} and every
satisfier @emph{v} such that @emph{S} and @emph{X} satisfy
@emph{Y@sup{v}}, add every protection condition in @emph{Z@sup{u}} to
the list of protected conditions.

@end itemize

Here is an example:

@multitable {Result(@emph{S,h@sup{u}})result(@emph{S,o@sup{u}})} {(:operator (!set-money ?person ?old ?new)((has-money ?person ?old))((has-money ?person ?old))((has-money ?person ?new)))}
@item
@emph{S}
 @tab @code{((has-money john 40) (has-money mary 30))}
@item
@emph{T}
 @tab @code{(!set-money john 40 35)}
@item
@emph{O}
 @tab

@lisp
(:operator (!set-money ?person ?old ?new)
    ((has-money ?person ?old))
    ((has-money ?person ?old))
    ((has-money ?person ?new)))
@end lisp
@item
@emph{U}
 @tab
 @code{((?person . john) (?old . 40) (?new . 35))}
@item
@emph{o@sup{u}}
 @tab
@lisp
(:operator (!set-money john 40 35)
    ((has-money john 40))
    ((has-money john 40))
    ((has-money john 35)))
@end lisp
@item
@emph{h@sup{u}}
 @tab @code{(!set-money john 40 35)}
@item
Result(@emph{S,h@sup{u}})

result(@emph{S,o@sup{u}})
 @tab @code{((has-money john 35) (has-money mary 30) )}

@code{((has-money john 35) (has-money mary 30) )}
@end multitable

Here is an example using the forall keyword

@multitable {Result(@emph{S,h@sup{u}}) result(@emph{S,o@sup{u}})} {(:operator (!clear-locations)@ @  ((forall (?l) ((location ?l)(not (truck-at ?t ?l)))@  ((location ?l))))())}
@item
@emph{S}
 @tab @code{((location l1) (location l2) (location l3) (truck-at truck1 l1))}
@item
@emph{T}
 @tab @code{(!clear-locations)}
@item
@emph{O}
 @tab
@lisp
 (:operator (!clear-locations)
    ((forall (?l)
        ((location ?l)
        (not (truck-at ?t ?l)))
    ((location ?l))))
    ())
@end lisp

@item
@emph{U}
 @tab ()
@item
@emph{o@sup{u}}
 @tab
 @lisp
(:operator (!clear-locations)
    (forall (?l)
        ((location ?l)
         (not (truck-at ?t ?l))))
     ((location ?l))
    ())
@end lisp

@item
@emph{h@sup{u}} =
 @tab @code{(!clear-locations)}
@item
Result(@emph{S,h@sup{u}})
 @tab @code{((location l1) (truck-at truck1 l1))}
 @item
result(@emph{S,o@sup{u}})
@tab
@code{((location l1) (truck-at truck1 l1))}
@end multitable

@node Semantics of Methods, Semantics of Plans, Semantics of Operators, Formal Semantics
@subsection Semantics of Methods
@anchor{#semantics-of-methods}
The purpose of a method is to specify the following:

@itemize
@item
If the current state of the world satisfies @var{C@sub{1}}, then
@var{h} can be accomplished by performing the tasks in @var{T@sub{1}}
in the order given;

@item
otherwise, if the current state of the world satisfies @var{C@sub{2}},
then @var{h} can be accomplished by performing the tasks in
@var{T@sub{2}} in the order given;

@item
@dots{};

@item
otherwise, if the current state of the world satisfies @var{C@sub{k}},
then @var{h} can be accomplished by performing the tasks in
@var{T@sub{k}} in the order given.

@end itemize

Let @var{S} be a state, @var{X} be an axiom list, @var{t} be a task
atom (which may or may not be ground), and @var{m} be the method
@code{(:method @var{h} @var{C@sub{1} T@sub{1} C@sub{2} T@sub{2}
@dots{} C@sub{k} T@sub{k})}}. Suppose there is an mgu (most general
unifier) @var{u} that unifies @var{t} with @var{h}; and suppose that
@var{m} has a precondition @var{C@sub{i}} such that @var{S} and
@var{X} satisfy @var{C@sub{i}@sup{u}}; if there is more than one such
precondition, then let @var{C@sub{i}} be the first such.
Then we say that @var{m} is @strong{applicable} to @var{t} in @var{S}
and @var{X}, with the @strong{active precondition} @var{C@sub{i}} and
the @strong{active tail} @var{T@sub{i}}. Then the result of applying
@var{m} to @var{t} is the set of task lists

@quotation
@var{R} = @{@sc{call}((@var{T@sub{i}@sup{u}})@var{@sup{v}}):
@var{v} is an mgs for @var{C@sub{i}@sup{u}} from @var{S} and @var{X}@}
@end quotation
@noindent
where @sc{call} is @sysname's evaluation function (the function that
evaluates the values of the call terms in the form @code{(call f t@sub{1}
t@sub{2} .. t@sub{n})}). Each task list @var{r} in @var{R} is called a
@strong{simple reduction} of @var{t} by @var{m} in @var{S} and
@var{X}. Here is an example:

@multitable {@emph{call}((@emph{T@sup{u}})@emph{@sup{v}})} {(:method (transfer-money ?p1 ?p2 ?amount)((has-money ?p1 ?m1)(has-money ?p2 ?m2)(call >= ?m1 ?amount))(:ordered (:task !set-money ?p1 ?m1(call - ?m1 ?amount))(:task !set-money ?p2 ?m2(call + ?m2 ?amount))))}
@item
@emph{S}
 @tab @code{((has-money john 40) (has-money mary 30))}
@item
@emph{X}
 @tab @code{nil}
@item
@emph{t}
 @tab @code{(transfer-money john mary 5)}
@item
@emph{M }
 @tab
@lisp
 (:method (transfer-money ?p1 ?p2 ?amount)
    ((has-money ?p1 ?m1)
     (has-money ?p2 ?m2)
     (call >= ?m1 ?amount))
    (:ordered (:task !set-money ?p1 ?m1 (call - ?m1 ?amount))
                   (:task !set-money ?p2 ?m2 (call + ?m2 ?amount))))
@end lisp

@item
@emph{u}
 @tab @code{((?p1 . john) (?p2 . mary) (?amount . 5))}
@item
@emph{h@sup{u}}
 @tab @code{(transfer-money john mary 5)}
@item
@emph{C@sub{1}@sup{u}}
 @tab
 @lisp
((has-money john ?m1)
 (has-money mary ?m2)
 (call >= ?m1 5))
@end lisp

@item
@emph{T@sub{1}@sup{u}}
 @tab
 @lisp
(:ordered
     (:task !set-money john ?m1 (call - ?m1 5))
     (:task !set-money mary ?m2 (call + ?m2 5)))
@end lisp

@item
@emph{v}
 @tab @code{((?m1 . 40) (?m2 . 30))}
@item
(@emph{C@sub{1}@sup{u}})@emph{@sup{v}}
 @tab
 @lisp
((has-money john 40)
  (has-money mary 30)
  (call >= 40 30))
@end lisp

@item
(@emph{T@sup{u}})@emph{@sup{v}}
 @tab
 @lisp
(:ordered
     (:task !set-money john 40 (call - 40 5))
     (:task !set-money mary 30 (call + 30 5)))
@end lisp
@item
@emph{call}((@emph{T@sup{u}})@emph{@sup{v}})
 @tab
 @lisp
(:ordered
     (:task !set-money john 40 35)
     (:task !set-money mary 30 35))
@end lisp

@end multitable

@node Semantics of Plans,  , Semantics of Methods, Formal Semantics
@subsection Semantics of Plans
@anchor{#semantics-of-plans}
Recall that a planning domain contains axioms, operators, and methods,
and that a planning problem is a 4-tuple (@emph{S,M,L,D}), where
@emph{S} is a state, @emph{M} is a task list, @emph{L} is a protection
list, and @emph{D} is a domain representation.@  Let @emph{T} be the
list of tasks in @emph{M} that have no predecessor (i.e., those tasks
can be performed at this time if they are applicable).@ @  If @emph{t}
is a task in @emph{T,} and @emph{S} is a state, then a
@strong{reduction} of @emph{t} in @emph{S} and D with respect to
@emph{M} and @emph{L} that results in a new planning problem
(@emph{S',M',L',D)@ } is defined as follows:

@quotation
@strong{if} @emph{t} is a primitive task, @strong{then}

(@emph{S'}, @emph{L'}) = result(@emph{S,L,t});

@emph{M'} = the task list produced by removing @emph{t} from @emph{M}

@strong{else} @emph{t} is a compound task, @strong{then}

@emph{S'} = @emph{S};

@emph{L'} = @emph{L};

Suppose @emph{m} is an applicable method to @emph{t} in @emph{S}, with
unifier @emph{u,} the active precondition @emph{C@sub{i}} and the active
tail @emph{T@sub{i}.}

@emph{M' =} the task list produced by replace @emph{t} with
@emph{T@sub{i}@sup{u}} in @emph{M}
@end quotation
@strong{endif}

If @emph{P} = (@emph{p}@sub{1} @emph{p}@sub{2} @dots{} @emph{p@sub{n}}) is a
plan, then we say that @emph{P} @strong{solves} (@emph{S,M,L,D}), or
equivalently, that @emph{P} achieves @emph{M} from @emph{S} in @emph{D}
(we will omit the phrase "in @emph{D}" if the identity of @emph{D} is
obvious) in any of the following cases:

@strong{Case 1}.

both @emph{M} and @emph{P} are empty.

@strong{Case 2}.

@quotation
@emph{T} = (@emph{t}@sub{1} @emph{t}@sub{2} @dots{} @emph{t@sub{k}}) is a
list of tasks in @emph{M} that have no predecessor for which there is a
task @emph{t}@sub{i} that has the @code{:immediate} keyword and is applicable
to the current state @emph{S}.@  Let (@emph{S', M', L'}) =
reduction(@emph{t@sub{i}, S, M, L}).@  We say @emph{P}
@strong{solves}(@emph{S,M,L,D}) if either of the following is true.
@end quotation
@itemize
@item
@emph{t@sub{i}} is primitive and@  @emph{p@sub{1} = t@sub{i}} and
(@emph{p@sub{2}@  p@sub{3} @dots{} p@sub{n}}) solves (@emph{S', M', L', D})

@item
@emph{t@sub{i}} is not primitive, and @emph{P} solves (@emph{S', M', L',
D})

@end itemize

@strong{Case 3.}

@quotation
@emph{T} = (@emph{t}@sub{1} @emph{t}@sub{2} @dots{} @emph{t@sub{k}}) is a
list of tasks in @emph{M} that have no predecessor, where
@emph{t}@sub{i} is a task in @emph{T} that's applicable to the current
state @emph{S}.@  Let (@emph{S', M', L'}) = reduction(@emph{t@sub{i}, S,
M, L}).@  We say @emph{P} @strong{solves} (@emph{S,M,L,D}) if either of
the following is true.
@end quotation
@itemize
@item
@emph{t@sub{i}} is primitive and @emph{p@sub{1} = t@sub{i}} and
(@emph{p@sub{2}@  p@sub{3} @dots{} p@sub{n}}) solves (@emph{S', M', L', D})

@item
@emph{t@sub{i}} is not primitive and @emph{P} solves (@emph{S', M', L',
D})

@end itemize

The planning problem (@emph{S,M,L,D}) is @strong{solvable} if there is a
plan that solves it. For example, suppose that

@multitable {PP} {((:operator (!do ?operation) nil ((did ?operation))))}   {(:method (do-both ?x ?y) nil)}
@item
S
 @tab @code{nil}
@item
M
 @tab
@code{ ((:ordered (:task do-both op1 op2)))}
@item
T
 @tab @code{((:task do-both op1 op2))}
@item
L
 @tab nil
@item
D
 @tab
 @lisp
(
    (:operator (!do ?operation) nil ((did ?operation)))
    (:method (do-both ?x ?y)
           nil
           (:ordered
               (:task !do ?x)
               (:task !do ?y)))
    (:method (do-both ?x ?y)
        nil
        (:ordered (:task !do ?y)
               (:task !do ?x))))
@end lisp
@item
P@sub{1}
@tab @code{((do op1) 1 (do op2) 1)}
@item
P@sub{2}
 @tab
@code{((do op2) 1 (do op1) 1)}
@end multitable

Then P@sub{1} and P@sub{2} are all of the plans that solve
(@emph{S,M,L,D}).

@node Key Functions in SHOP3,  , Formal Semantics, Internal Technical Information
@section Key Functions in @sc{Shop3}
Below are some important functions in the Lisp implementation of @sysname.
They should be of interest to anyone who wishes to modify @sysname {} or to
directly access internal capabilities of @sysname. Pseudocode algorithms
for the main planning functions of @sysname {} are also presented.

@lisp
(apply-substitution e u)
@end lisp

@emph{e} is an expression and @emph{u} is a substitution. The function
returns @emph{e@sup{u}}.

(compose-substitutions u v)

@quotation
If @emph{u} and @emph{v} are substitutions, then this function returns a
substitution @emph{w} such that for every expression @emph{e},
@emph{e@sup{w}} = (@emph{e@sup{u}})@emph{@sup{v}}.
@end quotation
(standardizer e)

This function returns a standardizer for @emph{e}.

(standardize e)

This function is equivalent to (apply-substitution e (standardizer e)).

(unify d e)

@quotation
This procedure returns an mgu for the expressions @emph{d} and @emph{e}
if they are unifiable, and returns fail otherwise.
@end quotation
(find-satisfiers C S &optional just-one)

@quotation
If @emph{C} is a conjunct and @emph{S} is a state, then this function
returns a list of mgs's, one for every most general instance of @emph{C}
that is satisfied by @emph{S}. If the optional argument @emph{just-one}
is not nil, then the function returns the first mgs it finds, rather
than all of them. Calling (find-satisfiers C S) is roughly equivalent to
calling the following (simplified) pseudocode:

@strong{procedure} find-satisfiers(C, S)

@strong{if} C is empty @strong{then return} @{nil@}

l = the first logical atom in C; B = the remaining logical atoms in C

answers = nil

@strong{if} l is an expression of the form (not e) @strong{then}

@strong{if} find-satisfiers(e, S, nil) = nil @strong{then}

@strong{return} find-satisfiers(B, S)

@strong{else}

@strong{return} nil

@strong{end if}

@strong{else if} l is an expression of the form (eval e) @strong{then}

@strong{if} eval(e) is not nil @strong{then}

@strong{return} find-satisfiers(B, S)

@strong{else}

@strong{return} nil

@strong{end if}

@strong{else if} l is an expression of the form (or p@sub{1} p@sub{2}
@dots{} p@sub{n}) @strong{then}

@strong{for} every unifier u that unifies any p@sub{i} with l

@strong{for} every v in find-satisfiers(B@sup{u}, S)

@strong{insert} compose-substitutions(u,v) into answers

@strong{end for}

@strong{end for}

@strong{else if} l is an expression of the form (imply C@sub{1}
C@sub{2}) @strong{then}

mgu = find-satisfiers(C@sub{1}, S)

@strong{if} mgu is null or there exist a unifier u in mgu such that

find-satisfiers(C@sub{2}@sup{u}, S) is not equal to nil @strong{then}

@strong{return} find-satisfiers(B, S)

@strong{else}

@strong{return} nil

@strong{end if}

@strong{else if} l is an expression of the form

(forall variables bounds conditions) @strong{then}

mgu = find-satisfiers(bounds, S)

@strong{if} mgu is null or for every unifier u in mgu,

find-satisfiers(conditions@sup{u}, S) is not equal to nil @strong{then}

@strong{return} find-satisfiers(B, S)

@strong{else}

@strong{return} nil

@strong{end if}

@strong{else}

@strong{for} every atom s in S that unifies with l

@strong{let} u be the unifier

@strong{for} every v in find-satisfiers(B@sup{u}, S)

@strong{insert} compose-substitutions(u,v) into answers

@strong{end for}

@strong{end for}

@strong{for} every axiom x in *axioms* whose head unifies with l

@strong{let} u be the unifier

@strong{if} tail(x) contains a conjunct D such that

find-satisfiers(append(D@sup{u}, B@sup{u}), S) is not nil @strong{then}

@strong{let} D be the first such conjunct

@strong{for} every v in find-satisfiers(append(D@sup{u}, B@sup{u}), S)

@strong{insert} compose-substitutions(u, v)

into answers

@strong{end for}

@strong{end if}

@strong{end for}

@strong{end if}

@strong{return} answers

@strong{end} find-satisfiers

In this pseudo-code, @code{*axioms*} is an internal variable of @sysname. It holds
the list of the axioms defined for the domain under consideration.
@end quotation
@code{(apply-method S t m)}

If @emph{S} is a state, @emph{t} is a task, and
@emph{m} = @code{(:method h C@sub{1} T@sub{1} C@sub{2} T@sub{2} @dots{} C@sub{k} T@sub{k}) }is a method,
then this function does the following:

@itemize
@item
If @emph{m} is not applicable to @emph{t} in @emph{S}, then the function
returns the symbol @code{FAIL}.

@item
If @emph{m} is applicable to @emph{t} in @emph{S} and @emph{C@sub{i}} is
the active precondition, then the function returns a list of all simple
reductions of @emph{T@sub{i}}, one for each satisfier of @emph{C@sub{i}}
in @emph{S}.

@end itemize

@code{(apply-operator S t o)}

If @emph{S} is a state, @emph{t} is a task, and @emph{o} is an operator,
then this function does the following:

@itemize
@item
If there is an mgu @emph{u} for @emph{o} and @emph{t}, then it returns
the state produced by executing @emph{o@sup{u}} in @emph{S}.

@item
Otherwise, it returns FAIL.
@end itemize

@code{(find-plans problem &key which verbose pshort gc pp state plan-tree optimize-cost time-limit explanation)}

This function implements the @sysname {} planning algorithm. For more about
the arguments to and use of this function, @pxref{find-plans}. A brief
overview of the algorithm for this function is presented here. Calling
find-plans is roughly equivalent to calling the following pseudocode,
where @emph{S} is the current state, @emph{T} is a partially ordered set
of tasks, and @emph{L} is a list of protected conditions:

@strong{procedure} find-plans (@emph{S,T,L})

@strong{if} @emph{T} is empty @strong{then}

@strong{return} NIL

@strong{endif}

nondeterministically choose a task @emph{t} in @emph{T} that has no
predecessors

<@emph{r,R'}> = reduction (@emph{S},@emph{t})

@strong{if} @emph{r} = FAIL @strong{then }

@strong{return} FAIL

@strong{endif}

nondeterministically choose an operator instance @emph{o} applicable to
@emph{r} in @emph{S}

@emph{S'} = the state produced from @emph{S} by applying @emph{o} to
@emph{r}

@emph{L'} = the protection list produced from @emph{L} by applying
@emph{o} to @emph{r}

@emph{T'} = the partially ordered set of tasks produced from @emph{T} by
replacing @emph{t} with @emph{R'}

@emph{P} = find-plans (@emph{S'},@emph{T'},@emph{L'})

@strong{return} cons(@emph{o},@emph{P})

@strong{end} find-plans

@strong{procedure} reduction (@emph{S,t})

@strong{if} @emph{t} is a primitive task @strong{then }

@strong{return} <@emph{t},NIL>

@strong{else if} no method is applicable to @emph{t} in @emph{S}
@strong{then}

@strong{return} <FAIL,NIL>

@strong{endif}

nondeterministically let @emph{m} be any method applicable to @emph{t}
in @emph{S}

@emph{R} = the decomposition (partially ordered set of tasks) produced
by @emph{m} from @emph{t}

@emph{r} = any task in @emph{R} that has no predecessors

<@emph{r',R'}> = reduction (@emph{S},@emph{r})

@strong{if} @emph{r'} = FAIL @strong{then }

@strong{return} <FAIL,NIL>

@strong{endif}

@emph{R''} = the partially ordered set of tasks produced from @emph{R}
by replacing @emph{r} with @emph{R'}

@strong{return} <@emph{r}'@strong{,}@emph{R''}>

@strong{end} reduction

@code{(defdomain @emph{domain-name D})}


This macro gives the name @emph{domain-name} to planning domain
@emph{D}. (More specifically, what it does is to store @emph{D}'s
axioms, operators, and methods on @emph{domain-name}'s property list.)

@code{(defproblem @emph{problem-name domain-name S T})}


This macro gives the name @emph{problem-name} to the planning problem
@emph{(S,T,D)}, where @emph{D} is the planning domain whose name is
@emph{domain-name}. (More specifically, what it does is to store
@emph{S}, @emph{T}, and @emph{domain-name} on @emph{problem-name}'s
property list.)

@lisp
(def-problem-set @emph{set-name list-of-problems})
@end lisp



This macro gives the name @emph{set-name} to the set of planning
problems in @emph{list-of-problems}. (More specifically, what it does is
to store @emph{list-of-problems} on @emph{set-name}'s property list.)

Note that for backwards compatibility, @sysname {} also accepts the forms
@code{make-domain}, @code{make-problem}, and @code{make-problem-set}, which were employed in
SHOP 1.x, using the same arguments as @code{defdomain}, @code{defproblem}, and
@code{def-problem-set}. The difference between the @code{make-@i{X}} and @code{def-@i{X}} forms is
that in the latter case since the form is a macro, the arguments
are not evaluated. This changes the syntax one uses. Thus in a SHOP 1.x
domain one might define a problem as

@lisp
(make-problem ‘@var{problem-name} ‘@var{domain-name}
    ‘@var{(list of state atoms)}
    ‘@var{(list of tasks to be accomplished)})
@end lisp

@noindent
whereas in @sysname {} the syntax becomes

@lisp
(defproblem problem-name domain-name
    (list of state atoms)
    (list of tasks to be accomplished))
@end lisp

@noindent
where the arguments are all quoted in the SHOP 1.x make-problem
function, they are unquoted when using the @sysname {} defproblem macro.

@code{(print-axioms &optional @var{name})}

This function prints a list of the axioms for the domain whose name is
@emph{name}; defaults to the most recently defined domain.

@code{(print-operators &optional @var{name})}

This function prints a list of the operators for the domain whose name
is @emph{name}; defaults to the most recently defined domain.

@code{(print-methods &optional @var{name})}

This function prints a list of the methods for the domain whose name is
@emph{name}; defaults to the most recently defined domain.

@code{(get-state @var{name})}

This function returns the initial state for the problem whose name is
@var{name}.

@code{(get-tasks @var{name})}

This function returns the list of tasks for the problem whose name is
@var{name}.

@code{(get-problems @var{name})}

This function returns the list of problem names for the problem set
whose name is @var{name}.

@code{(do-problems @var{name-or-list} &rest keywords)}

@var{name-or-list} should be either a list of problem names or the name
of a problem set. This function runs @code{find-plans} on each planning problem
specified by the list or problem set, and then returns nil. The keywords
are simply passed on to find-plans.




@node Acknowledgments, References, Internal Technical Information, Top
@chapter Acknowledgments
@anchor{#acknowledgments}

Thanks to Kostas N. Oikonomou for multiple corrections, edits, and
improvements to the @sysname{} manual.

Original University of Maryland work on @sysname {} was supported in part by
the following grants, contracts, and awards: Air Force Research
Laboratory F30602-99-1-0013 and F30602-00-2-0505, Army Research
Laboratory DAAL01-97-K0135, and National Science Foundation DMI-9713718,
and the University of Maryland General Research Board.

SIFT, LLC work on @sysname {} has been supported by DARPA SBIR contract
DAAH01-03-C-R177, Army AFDD contract NAS-0155(MJH), Delivery Order 920,
by the Air Force Research Laboratory (AFRL) under contract
FA8750-16-C-0182,and by Contract FA8650-11-C-7191 with the US Defense
Advanced Research Projects Agency (DARPA) and the Air Force Research
Laboratory.

SIFT LLC work was also supported by Internal Research and Development.

Joint SIFT, LLC and University of Maryland work was supported by DARPA
contract FA8650-06-C-7606.

Previous SIFT work on the manual was supported by the Defense Advanced
Research Projects Agency (DARPA) and the Air Force Research Laboratory
under Contract No. FA8750-17-C-0184.

Any opinions, findings and conclusions or recommendations expressed in
this material are those of the author(s) and do not necessarily reflect
the views of the Defense Advanced Research Projects Agency (DARPA), the
Department of Defense, the National Science Foundation, the University
of Maryland, SIFT, or the United States Government.

@node References, Function Index, Acknowledgments, Top
@chapter References
@anchor{#references}

@anchor{DeanBoddy1998}
[Dean and Boddy, 1998] T. Dean and M. Boddy. An analysis of
time-dependent planning. In @emph{AAAI-88}, 1988.

@anchor{GhallabEtAl2004}
[Ghallab @emph{et al.}, 2004] M. Ghallab, D. Nau, P. Traverso. Automated
Planning: Theory and Practice, Morgan Kaufmann, 2004.

@anchor{GoldmanKuter2019}
[Goldman & Kuter, 2019] Goldman, R. P., & Kuter, U.
@uref{https://rpgoldman.goldman-tribe.org/papers/2019-els-SHOP3.pdf,
Hierarchical Task Network Planning in Common Lisp: the case of SHOP3}.
@i{ Proceedings of the 12th European Lisp Symposium}. European Lisp
Symposium, Genova, Italy, April 2019.

[Nau @emph{et al.}, 1999] D. Nau, Y. Cao, A. Lotem, and H. Muñoz-Avila.
SHOP: Simple Hierarchical Ordered Planner. In @emph{IJCAI-99}, 1999.

[Nau @emph{et al.}, 2000] D. S. Nau, Y. Cao, A. Lotem, and H.
Muñoz-Avila. SHOP and M-SHOP: Planning with Ordered Task Decomposition.
Tech report TR 4157, University of Maryland, College Park, MD, June
2000.

@anchor{NauEtAl2001}
[Nau @emph{et al.}, 2001] D. S. Nau, H. Muñoz-Avila Y. Cao, A. Lotem,
and.S. Mitchell. Totally Ordered Planning with Partially Ordered
Subtasks. In @emph{IJCAI-01}, 2001.

@node Function Index, Type and Class Index, References, Top
@unnumbered Function and Macro Index
@printindex fn

@node Type and Class Index, Variable Index, Function Index, Top
@unnumbered Type and Class Index
@printindex tp


@node Variable Index, Concept Index, Type and Class Index, Top
@unnumbered Variable Index
@printindex vr

@node Concept Index, Colophon, Variable Index, Top
@unnumbered Concept Index
@printindex cp

@node Colophon,  , Concept Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Colophon

This manual is maintained in Texinfo, and automatically translated
into other forms (e.g. HTML or pdf). If you're @emph{reading} this
manual in one of these non-Texinfo translated forms, that's fine, but
if you want to @emph{modify} this manual, you are strongly advised to
seek out a Texinfo version and modify that instead of modifying a
translated version.

This manual was made possible in part by the @code{SB-TEXINFO} library
provided by Nikodemus Siivola and Rudi Schlatte, for which we are very grateful.


@bye

@c  LocalWords:  Ghallab nonprimitive
